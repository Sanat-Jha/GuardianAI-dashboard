<script>
// Toggle Add Child Modal
function toggleAddChildModal() {
  const modal = document.getElementById('addChildModal');
  modal.classList.toggle('hidden');
}

// Delete Child with Confirmation
function confirmDeleteChild(childHash, childName) {
  if (confirm(`Are you sure you want to delete ${childName}?\n\nThis will permanently delete all data including:\n- Screen time history\n- Location history\n- Site access logs\n- App usage data\n\nThis action cannot be undone.`)) {
    deleteChild(childHash);
  }
}

async function deleteChild(childHash) {
  try {
    const response = await fetch(`/child/${childHash}/delete/`, {
      method: 'POST',
      headers: {
        'X-CSRFToken': getCookie('csrftoken'),
        'Content-Type': 'application/json',
      },
    });
    
    const data = await response.json();
    
    if (data.status === 'success') {
      // Show success message
      alert(data.message);
      
      // Reload the page to refresh the child list
      window.location.reload();
    } else {
      alert('Error: ' + data.message);
    }
  } catch (error) {
    console.error('Error deleting child:', error);
    alert('An error occurred while deleting the child. Please try again.');
  }
}

// Helper function to get CSRF token
function getCookie(name) {
  let cookieValue = null;
  if (document.cookie && document.cookie !== '') {
    const cookies = document.cookie.split(';');
    for (let i = 0; i < cookies.length; i++) {
      const cookie = cookies[i].trim();
      if (cookie.substring(0, name.length + 1) === (name + '=')) {
        cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
        break;
      }
    }
  }
  return cookieValue;
}

// Close modal on outside click
document.getElementById('addChildModal')?.addEventListener('click', function(e) {
  if (e.target === this) {
    toggleAddChildModal();
  }
});

// Child Selection Logic for Sidebar
window.selectChild = function(childHash) {
  console.log('Selecting child:', childHash);
  
  // Update active state in sidebar
  document.querySelectorAll('.child-item').forEach(item => {
    item.classList.remove('active-child');
    const indicator = item.querySelector('.child-indicator');
    if (indicator) {
      indicator.style.opacity = '0';
    }
  });
  
  // Set active state for selected child
  const selectedItem = document.querySelector(`[data-child-hash="${childHash}"]`);
  if (selectedItem) {
    selectedItem.classList.add('active-child');
    const indicator = selectedItem.querySelector('.child-indicator');
    if (indicator) {
      indicator.style.opacity = '1';
    }
  }
  
  // Hide all child dashboards
  document.querySelectorAll('.child-dashboard').forEach(dash => {
    dash.classList.add('hidden');
  });
  
  // Show/hide select prompt
  const selectPrompt = document.getElementById('selectPrompt');
  if (childHash) {
    if (selectPrompt) selectPrompt.classList.add('hidden');
    
    // Show selected child dashboard
    const selectedDash = document.getElementById('child-' + childHash);
    if (selectedDash) {
      selectedDash.classList.remove('hidden');
      console.log('Showing dashboard for child:', childHash);
      
      // Load charts for this child
      loadChartsForChild(childHash);
    } else {
      console.error('Dashboard not found for child:', childHash);
    }
  } else {
    if (selectPrompt) selectPrompt.classList.remove('hidden');
  }
}

// Load Charts Function
function loadChartsForChild(childHash) {
  // Check if charts already exist
  const lineCanvas = document.getElementById('lineChart' + childHash);
  const barCanvas = document.getElementById('barChart' + childHash);
  const appAnalyticsDiv = document.getElementById('appAnalytics' + childHash);
  
  if (!lineCanvas || !barCanvas) {
    console.error('Chart canvases not found for child:', childHash);
    return;
  }
  
  // Fetch chart data
  fetch('/dashboard/chart-data/' + childHash + '/')
    .then(response => {
      if (!response.ok) {
        throw new Error('Network response was not ok: ' + response.statusText);
      }
      return response.json();
    })
    .then(data => {
      console.log('Chart data loaded:', data);
      
      // Destroy existing charts if any
      if (window.chartsInstances && window.chartsInstances[childHash]) {
        window.chartsInstances[childHash].line?.destroy();
        window.chartsInstances[childHash].bar?.destroy();
      }
      
      // Initialize charts storage
      if (!window.chartsInstances) window.chartsInstances = {};
      if (!window.chartsInstances[childHash]) window.chartsInstances[childHash] = {};
      
      // 1. LINE CHART - Screen Time Trend with Gradient
      const lineCtx = lineCanvas.getContext('2d');
      const gradient = lineCtx.createLinearGradient(0, 0, 0, 300);
      gradient.addColorStop(0, 'rgba(35, 210, 226, 0.3)');
      gradient.addColorStop(1, 'rgba(35, 210, 226, 0.0)');
      
      window.chartsInstances[childHash].line = new Chart(lineCtx, {
        type: 'line',
        data: {
          labels: data.line_chart.labels,
          datasets: [{
            label: 'Screen Time (hours)',
            data: data.line_chart.data,
            borderColor: '#23D2E2',
            backgroundColor: gradient,
            borderWidth: 3,
            fill: true,
            tension: 0.4,
            pointBackgroundColor: '#23D2E2',
            pointBorderColor: '#0F1B2A',
            pointBorderWidth: 3,
            pointRadius: 5,
            pointHoverRadius: 8,
            pointHoverBackgroundColor: '#8EF6FF',
            pointHoverBorderColor: '#FFFFFF',
            pointHoverBorderWidth: 3,
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          interaction: {
            intersect: false,
            mode: 'index'
          },
          plugins: {
            legend: {
              display: true,
              position: 'top',
              align: 'end',
              labels: { 
                color: '#A9B3C1', 
                font: { size: 12, weight: '600', family: 'Inter' },
                padding: 15,
                usePointStyle: true,
                pointStyle: 'circle'
              }
            },
            tooltip: {
              backgroundColor: 'rgba(15, 27, 42, 0.95)',
              titleColor: '#8EF6FF',
              bodyColor: '#FFFFFF',
              borderColor: '#23D2E2',
              borderWidth: 2,
              padding: 12,
              titleFont: { size: 14, weight: '700', family: 'Inter' },
              bodyFont: { size: 13, family: 'Inter' },
              displayColors: false,
              callbacks: {
                title: function(tooltipItems) {
                  return 'Date: ' + tooltipItems[0].label;
                },
                label: function(context) {
                  return 'Usage: ' + context.parsed.y.toFixed(2) + ' hours';
                }
              }
            }
          },
          scales: {
            y: {
              beginAtZero: true,
              ticks: { 
                color: '#A9B3C1', 
                font: { size: 11, family: 'Inter' },
                callback: function(value) {
                  return value + 'h';
                }
              },
              grid: { 
                color: 'rgba(169, 179, 193, 0.08)',
                drawBorder: false
              },
              border: { display: false }
            },
            x: {
              ticks: { 
                color: '#A9B3C1', 
                font: { size: 11, family: 'Inter' },
                maxRotation: 45,
                minRotation: 45
              },
              grid: { 
                display: false
              },
              border: { display: false }
            }
          }
        }
      });

      // 2. HORIZONTAL BAR CHART - App Usage Distribution (TOP 5 ONLY)
      const barCtx = barCanvas.getContext('2d');
      
      // Calculate total time from all apps
      const totalTime = data.app_list.data.reduce((a, b) => a + b, 0);
      document.getElementById('totalAppTime' + childHash).textContent = totalTime.toFixed(1) + 'h';
      
      window.chartsInstances[childHash].bar = new Chart(barCtx, {
        type: 'bar',
        data: {
          labels: data.bar_chart.labels,
          datasets: [{
            label: 'Usage (hours)',
            data: data.bar_chart.data,
            backgroundColor: [
              'rgba(35, 210, 226, 0.9)',
              'rgba(142, 246, 255, 0.9)',
              'rgba(24, 164, 180, 0.9)',
              'rgba(123, 108, 246, 0.9)',
              'rgba(184, 167, 255, 0.9)',
            ],
            borderColor: [
              '#23D2E2',
              '#8EF6FF',
              '#18A4B4',
              '#7B6CF6',
              '#B8A7FF',
            ],
            borderWidth: 2,
            borderRadius: 8,
            barThickness: 32,
          }]
        },
        options: {
          indexAxis: 'y',
          responsive: true,
          maintainAspectRatio: false,
          plugins: {
            legend: {
              display: false
            },
            tooltip: {
              backgroundColor: 'rgba(15, 27, 42, 0.95)',
              titleColor: '#8EF6FF',
              bodyColor: '#FFFFFF',
              borderColor: '#23D2E2',
              borderWidth: 2,
              padding: 12,
              titleFont: { size: 13, weight: '600', family: 'Inter' },
              bodyFont: { size: 12, family: 'Inter' },
              displayColors: true,
              callbacks: {
                label: function(context) {
                  const hours = context.parsed.x.toFixed(2);
                  const percentage = ((context.parsed.x / totalTime) * 100).toFixed(1);
                  return hours + 'h (' + percentage + '%)';
                }
              }
            }
          },
          scales: {
            x: {
              beginAtZero: true,
              ticks: { 
                color: '#A9B3C1', 
                font: { size: 11, family: 'Inter' },
                callback: function(value) {
                  return value + 'h';
                }
              },
              grid: { 
                color: 'rgba(169, 179, 193, 0.08)',
                drawBorder: false
              },
              border: { display: false }
            },
            y: {
              ticks: { 
                color: '#FFFFFF', 
                font: { size: 12, weight: '500', family: 'Inter' }
              },
              grid: { 
                display: false
              },
              border: { display: false }
            }
          }
        }
      });

      // 3. APPLICATION ANALYTICS - Interactive List (ALL APPS)
      if (appAnalyticsDiv) {
        let analyticsHTML = '';
        
        if (data.app_list.labels[0] === 'No Data' || data.app_list.data.length === 0) {
          analyticsHTML = `
            <div class="text-center py-12">
              <svg class="w-16 h-16 mx-auto text-textsec/30 mb-3" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 19v-6a2 2 0 00-2-2H5a2 2 0 00-2 2v6a2 2 0 002 2h2a2 2 0 002-2zm0 0V9a2 2 0 012-2h2a2 2 0 012 2v10m-6 0a2 2 0 002 2h2a2 2 0 002-2m0 0V5a2 2 0 012-2h2a2 2 0 012 2v14a2 2 0 01-2 2h-2a2 2 0 01-2-2z"></path>
              </svg>
              <p class="text-textsec text-sm">No application data available</p>
              <p class="text-textsec/60 text-xs mt-1">Data will appear once the child uses their device</p>
            </div>
          `;
          // Update total apps count
          const totalAppsCountEl = document.getElementById('totalAppsCount' + childHash);
          if (totalAppsCountEl) totalAppsCountEl.textContent = '0';
        } else {
          const maxTime = Math.max(...data.app_list.data);
          
          // Update total apps count
          const totalAppsCountEl = document.getElementById('totalAppsCount' + childHash);
          if (totalAppsCountEl) totalAppsCountEl.textContent = data.app_list.labels.length;
          
          // Show ALL apps (not just top 5)
          data.app_list.labels.forEach((app, index) => {
            const time = data.app_list.data[index];
            const icon = data.app_list.icons ? data.app_list.icons[index] : '';
            const domain = data.app_list.domains ? data.app_list.domains[index] : '';
            const percentage = ((time / totalTime) * 100).toFixed(1);
            const barWidth = (time / maxTime * 100).toFixed(1);
            const minutes = Math.round((time % 1) * 60);
            const hours = Math.floor(time);
            
            // Color variations - cycling through colors for all apps
            const colors = [
              { bg: 'bg-cyan-500/20', border: 'border-cyan-500/40', text: 'text-cyan-400', bar: 'bg-cyan-500' },
              { bg: 'bg-teal-500/20', border: 'border-teal-500/40', text: 'text-teal-400', bar: 'bg-teal-500' },
              { bg: 'bg-purple-500/20', border: 'border-purple-500/40', text: 'text-purple-400', bar: 'bg-purple-500' },
              { bg: 'bg-violet-500/20', border: 'border-violet-500/40', text: 'text-violet-400', bar: 'bg-violet-500' },
              { bg: 'bg-emerald-500/20', border: 'border-emerald-500/40', text: 'text-emerald-400', bar: 'bg-emerald-500' },
              { bg: 'bg-blue-500/20', border: 'border-blue-500/40', text: 'text-blue-400', bar: 'bg-blue-500' },
              { bg: 'bg-indigo-500/20', border: 'border-indigo-500/40', text: 'text-indigo-400', bar: 'bg-indigo-500' },
              { bg: 'bg-pink-500/20', border: 'border-pink-500/40', text: 'text-pink-400', bar: 'bg-pink-500' },
              { bg: 'bg-rose-500/20', border: 'border-rose-500/40', text: 'text-rose-400', bar: 'bg-rose-500' },
              { bg: 'bg-orange-500/20', border: 'border-orange-500/40', text: 'text-orange-400', bar: 'bg-orange-500' },
            ];
            const color = colors[index % colors.length];
            
            // Generate app icon HTML with better fallback
            const appIconHTML = (icon && icon.trim() !== '')
              ? `<div class="relative w-8 h-8 flex-shrink-0">
                   <img src="${icon}" alt="${app}" class="w-8 h-8 rounded-lg object-cover" onerror="this.style.display='none'; this.nextElementSibling.style.display='flex';">
                   <div class="w-8 h-8 ${color.bg} ${color.border} border rounded-lg flex items-center justify-center absolute inset-0" style="display: none;">
                     <span class="text-xs font-bold ${color.text}">${app.charAt(0).toUpperCase()}</span>
                   </div>
                 </div>`
              : `<div class="w-8 h-8 ${color.bg} ${color.border} border rounded-lg flex items-center justify-center flex-shrink-0">
                   <span class="text-xs font-bold ${color.text}">${app.charAt(0).toUpperCase()}</span>
                 </div>`;
            
            analyticsHTML += `
              <div class="bg-black/30 border ${color.border} rounded-xl p-4 hover:bg-black/40 transition-all duration-300 group">
                <div class="flex items-start justify-between mb-3">
                  <div class="flex-1 flex items-start gap-3">
                    ${appIconHTML}
                    <div class="flex-1 min-w-0">
                      <h4 class="font-semibold text-textmain text-sm group-hover:${color.text} transition-colors mb-1 truncate">${app}</h4>
                      <p class="text-xs text-textsec truncate font-mono">${domain || 'Unknown domain'}</p>
                    </div>
                  </div>
                  <div class="text-right flex-shrink-0 ml-2">
                    <p class="text-2xl font-bold ${color.text}">${hours}<span class="text-sm">h</span></p>
                    ${minutes > 0 ? `<p class="text-xs text-textsec">${minutes}m</p>` : ''}
                  </div>
                </div>
                
                <div class="relative">
                  <div class="w-full bg-black/50 rounded-full h-2 overflow-hidden">
                    <div class="${color.bar} h-2 rounded-full transition-all duration-1000 ease-out" 
                         style="width: ${barWidth}%"></div>
                  </div>
                  <div class="absolute -top-1 right-0 text-xs ${color.text} font-semibold opacity-0 group-hover:opacity-100 transition-opacity">
                    ${time.toFixed(2)}h (${percentage}%)
                  </div>
                </div>
              </div>
            `;
          });
        }
        
        appAnalyticsDiv.innerHTML = analyticsHTML;
      }
    })
    .catch(error => {
      console.error('Error loading chart data:', error);
      
      // Show error in all sections
      [lineCanvas, barCanvas].forEach(canvas => {
        if (canvas) {
          const ctx = canvas.getContext('2d');
          ctx.fillStyle = '#FF4D5A';
          ctx.font = '14px Inter';
          ctx.textAlign = 'center';
          ctx.fillText('âš  Error loading data', canvas.width / 2, canvas.height / 2 - 10);
          ctx.fillStyle = '#A9B3C1';
          ctx.font = '12px Inter';
          ctx.fillText('Please refresh the page', canvas.width / 2, canvas.height / 2 + 10);
        }
      });
      
      if (appAnalyticsDiv) {
        appAnalyticsDiv.innerHTML = `
          <div class="text-center py-12">
            <svg class="w-16 h-16 mx-auto text-red-500/50 mb-3" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z"></path>
            </svg>
            <p class="text-red-400 text-sm font-semibold">Failed to load analytics</p>
            <p class="text-textsec text-xs mt-2">Please refresh the page or try again later</p>
          </div>
        `;
      }
    });
}

// Update App Chart with Date Range
function updateAppChart(childHash) {
  const startDateInput = document.getElementById('startDate' + childHash);
  const endDateInput = document.getElementById('endDate' + childHash);
  const startDate = startDateInput?.value;
  const endDate = endDateInput?.value;
  
  // Build URL with date parameters
  let chartUrl = '/dashboard/chart-data/' + childHash + '/';
  let statsUrl = '/dashboard/stats/' + childHash + '/';
  let locationsUrl = '/dashboard/locations/' + childHash + '/';
  let siteLogsUrl = '/dashboard/site-logs/' + childHash + '/';
  const params = new URLSearchParams();
  
  if (startDate) {
    params.append('start_date', startDate);
  }
  if (endDate) {
    params.append('end_date', endDate);
  }
  
  if (params.toString()) {
    chartUrl += '?' + params.toString();
    statsUrl += '?' + params.toString();
    locationsUrl += '?' + params.toString();
    siteLogsUrl += '?' + params.toString();
  }
  
  console.log('Fetching chart data with dates:', chartUrl);
  console.log('Fetching stats data with dates:', statsUrl);
  console.log('Fetching locations data with dates:', locationsUrl);
  console.log('Fetching site logs data with dates:', siteLogsUrl);
  
  // Fetch chart data, stats data, locations data, and site logs data in parallel
  Promise.all([
    fetch(chartUrl).then(res => {
      if (!res.ok) throw new Error('Chart data fetch failed');
      return res.json();
    }),
    fetch(statsUrl).then(res => {
      if (!res.ok) throw new Error('Stats data fetch failed');
      return res.json();
    }),
    fetch(locationsUrl).then(res => {
      if (!res.ok) throw new Error('Locations data fetch failed');
      return res.json();
    }),
    fetch(siteLogsUrl).then(res => {
      if (!res.ok) throw new Error('Site logs fetch failed');
      return res.json();
    })
  ])
    .then(([chartData, statsData, locationsData, siteLogsData]) => {
      console.log('Updated chart data loaded:', chartData);
      console.log('Updated stats data loaded:', statsData);
      console.log('Updated locations data loaded:', locationsData);
      console.log('Updated site logs data loaded:', siteLogsData);
      
      // Update line chart
      if (window.chartsInstances && window.chartsInstances[childHash]) {
        // Update line chart data
        if (window.chartsInstances[childHash].line) {
          window.chartsInstances[childHash].line.data.labels = chartData.line_chart.labels;
          window.chartsInstances[childHash].line.data.datasets[0].data = chartData.line_chart.data;
          window.chartsInstances[childHash].line.update();
        }
        
        // Update bar chart data (TOP 5 ONLY)
        if (window.chartsInstances[childHash].bar) {
          window.chartsInstances[childHash].bar.data.labels = chartData.bar_chart.labels;
          window.chartsInstances[childHash].bar.data.datasets[0].data = chartData.bar_chart.data;
          window.chartsInstances[childHash].bar.update();
          
          // Update total time display (from all apps)
          const totalTime = chartData.app_list.data.reduce((a, b) => a + b, 0);
          document.getElementById('totalAppTime' + childHash).textContent = totalTime.toFixed(1) + 'h';
        }
        
        // Update app analytics if present
        updateAppAnalytics(childHash, chartData);
      }
      
      // Update stat cards
      updateStatCards(childHash, statsData.stats);
      
      // Update location map
      updateLocationMap(childHash, locationsData.locations, locationsData.count);
      
      // Update site logs
      updateSiteLogs(childHash, siteLogsData.site_logs, siteLogsData.count);
    })
    .catch(error => {
      console.error('Error loading data:', error);
      alert('Failed to load data. Please try again.');
    });
}

// Update Stat Cards with new data
function updateStatCards(childHash, stats) {
  // Update Total Screen Time
  const totalStatCard = document.getElementById('stat-total-' + childHash);
  if (totalStatCard) {
    const valueEl = totalStatCard.querySelector('.stat-value');
    if (valueEl) {
      // Add animation class
      valueEl.classList.add('animate-pulse');
      valueEl.textContent = stats.total_screen_time_hours;
      setTimeout(() => valueEl.classList.remove('animate-pulse'), 1000);
    }
  }
  
  // Update Average Daily
  const avgStatCard = document.getElementById('stat-avg-' + childHash);
  if (avgStatCard) {
    const valueEl = avgStatCard.querySelector('.stat-value');
    if (valueEl) {
      valueEl.classList.add('animate-pulse');
      valueEl.textContent = stats.avg_screen_time_formatted;
      setTimeout(() => valueEl.classList.remove('animate-pulse'), 1000);
    }
  }
  
  // Update Latest Location
  const locationStatCard = document.getElementById('stat-location-' + childHash);
  if (locationStatCard) {
    const valueEl = locationStatCard.querySelector('.stat-value');
    if (valueEl) {
      valueEl.classList.add('animate-pulse');
      valueEl.textContent = stats.latest_location;
      setTimeout(() => valueEl.classList.remove('animate-pulse'), 1000);
    }
  }
  
  // Update Blocked Sites
  const blockStatCard = document.getElementById('stat-block-' + childHash);
  if (blockStatCard) {
    const valueEl = blockStatCard.querySelector('.stat-value');
    const subtitleEl = blockStatCard.querySelector('.stat-subtitle');
    if (valueEl) {
      valueEl.classList.add('animate-pulse');
      valueEl.textContent = stats.blocked_sites;
      setTimeout(() => valueEl.classList.remove('animate-pulse'), 1000);
    }
    if (subtitleEl) {
      subtitleEl.textContent = stats.site_access_count + ' total sites';
    }
  }
  
  console.log('Stat cards updated for child:', childHash);
}

// Update Location Map with new data
function updateLocationMap(childHash, locations, count) {
  const locationSection = document.getElementById('location-section-' + childHash);
  if (!locationSection) return;
  
  // Update location count badge
  const countBadge = locationSection.querySelector('.location-count-badge');
  if (countBadge) {
    countBadge.innerHTML = `${count} <span class="text-xs text-textsec font-normal">entries</span>`;
  }
  
  // Update location data
  if (window.locationData) {
    window.locationData[childHash] = locations;
  }
  
  const mapContainer = locationSection.querySelector('.location-map-container');
  if (!mapContainer) return;
  
  if (locations.length === 0) {
    // Show no data message
    mapContainer.innerHTML = `
      <div class="text-center py-12 no-location-message">
        <svg class="w-16 h-16 mx-auto text-textsec/30 mb-3" fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M17.657 16.657L13.414 20.9a1.998 1.998 0 01-2.827 0l-4.244-4.243a8 8 0 1111.314 0z"></path>
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 11a3 3 0 11-6 0 3 3 0 016 0z"></path>
        </svg>
        <p class="text-textsec text-sm font-medium">No location data for selected date range</p>
        <p class="text-textsec/60 text-xs mt-1">Try selecting a different date range</p>
      </div>
    `;
  } else {
    // Destroy existing map if it exists
    if (window.locationMaps && window.locationMaps[childHash]) {
      window.locationMaps[childHash].remove();
      delete window.locationMaps[childHash];
    }
    
    // Clear markers
    if (window.locationMarkers && window.locationMarkers[childHash]) {
      window.locationMarkers[childHash] = [];
    }
    
    // Recreate map container and controls
    mapContainer.innerHTML = `
      <div id="location-map-${childHash}"></div>
      <div class="map-controls">
        <button class="control-btn" onclick="fitAllMarkers('${childHash}')">
          <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 8V4m0 0h4M4 4l5 5m11-1V4m0 0h-4m4 0l-5 5M4 16v4m0 0h4m-4 0l5-5m11 5l-5-5m5 5v-4m0 4h-4"></path>
          </svg>
          Fit All
        </button>
        <button class="control-btn" onclick="togglePath('${childHash}')">
          <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 10V3L4 14h7v7l9-11h-7z"></path>
          </svg>
          Toggle Path
        </button>
        <button class="control-btn" onclick="showFirstLocation('${childHash}')">
          <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 12l2-2m0 0l7-7 7 7M5 10v10a1 1 0 001 1h3m10-11l2 2m-2-2v10a1 1 0 01-1 1h-3m-6 0a1 1 0 001-1v-4a1 1 0 011-1h2a1 1 0 011 1v4a1 1 0 001 1m-6 0h6"></path>
          </svg>
          First Location
        </button>
        <button class="control-btn" onclick="showLastLocation('${childHash}')">
          <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M17 8l4 4m0 0l-4 4m4-4H3"></path>
          </svg>
          Latest Location
        </button>
      </div>
    `;
    
    // Reinitialize map with new data
    setTimeout(() => {
      if (typeof initLocationMap === 'function') {
        initLocationMap(childHash);
        // Force map to recalculate size after initialization
        setTimeout(() => {
          if (window.locationMaps && window.locationMaps[childHash]) {
            window.locationMaps[childHash].invalidateSize();
          }
        }, 200);
      }
    }, 100);
  }
  
  console.log('Location map updated for child:', childHash, 'with', count, 'locations');
}

// Update Site Access Logs with new data
function updateSiteLogs(childHash, siteLogs, count) {
  const siteSection = document.getElementById('site-section-' + childHash);
  if (!siteSection) return;
  
  // Update site count badge
  const countBadge = siteSection.querySelector('.site-count-badge');
  if (countBadge) {
    countBadge.innerHTML = `${count} <span class="text-xs text-textsec font-normal">entries</span>`;
  }
  
  const logsContainer = siteSection.querySelector('.site-logs-container');
  if (!logsContainer) return;
  
  if (siteLogs.length === 0) {
    // Show no data message
    logsContainer.innerHTML = `
      <div class="text-center py-12">
        <svg class="w-16 h-16 mx-auto text-textsec/30 mb-3" fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 12a9 9 0 01-9 9m9-9a9 9 0 00-9-9m9 9H3m9 9a9 9 0 01-9-9m9 9c1.657 0 3-4.03 3-9s-1.343-9-3-9m0 18c-1.657 0-3-4.03-3-9s1.343-9 3-9m-9 9a9 9 0 019-9"></path>
        </svg>
        <p class="text-textsec text-sm font-medium">No site access data for selected date range</p>
        <p class="text-textsec/60 text-xs mt-1">Try selecting a different date range</p>
      </div>
    `;
  } else {
    // Rebuild site logs list
    let logsHTML = '';
    siteLogs.forEach(log => {
      const accessed = log.accessed;
      const statusColor = accessed ? 'lime' : 'red';
      const statusLabel = accessed ? 'ACCESSED' : 'BLOCKED';
      const statusIcon = accessed 
        ? '<svg class="w-3 h-3 inline mr-1" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7"></path></svg>'
        : '<svg class="w-3 h-3 inline mr-1" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg>';
      
      // Parse timestamp to readable format
      const timestamp = new Date(log.timestamp);
      const formattedDate = timestamp.toLocaleDateString('en-US', { 
        month: 'short', 
        day: 'numeric', 
        year: 'numeric' 
      }) + ' ' + timestamp.toLocaleTimeString('en-US', {
        hour: '2-digit',
        minute: '2-digit'
      });
      
      logsHTML += `
        <div class="relative bg-gradient-to-r from-black/40 to-black/20 rounded-lg p-4 border border-${statusColor}-500/20 hover:border-${statusColor}-500/40 transition-all duration-300 group/item">
          <!-- Left accent bar -->
          <div class="absolute left-0 top-0 bottom-0 w-1 bg-gradient-to-b from-${statusColor}-500 to-${statusColor}-600 rounded-l-lg"></div>
          
          <div class="flex flex-col gap-3 ml-2">
            <div class="flex items-center justify-between gap-4">
              <div class="flex items-center gap-2">
                <svg class="w-4 h-4 text-${statusColor}-400 flex-shrink-0" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 7V3m8 4V3m-9 8h10M5 21h14a2 2 0 002-2V7a2 2 0 00-2-2H5a2 2 0 00-2 2v12a2 2 0 002 2z"></path>
                </svg>
                <span class="text-textmain text-sm font-medium">${formattedDate}</span>
              </div>
              <span class="font-bold text-xs px-3 py-1 rounded-lg bg-${statusColor}-500/10 text-${statusColor}-400 border border-${statusColor}-500/30 shadow-lg">
                ${statusIcon}
                ${statusLabel}
              </span>
            </div>
            
            <div class="flex items-start gap-2 bg-black/50 p-3 rounded-lg border border-primary/10">
              <svg class="w-4 h-4 text-primary flex-shrink-0 mt-0.5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13.828 10.172a4 4 0 00-5.656 0l-4 4a4 4 0 105.656 5.656l1.102-1.101m-.758-4.899a4 4 0 005.656 0l4-4a4 4 0 00-5.656-5.656l-1.1 1.1"></path>
              </svg>
              <span class="break-all text-textsec text-sm font-mono leading-relaxed">${log.url}</span>
            </div>
          </div>
        </div>
      `;
    });
    
    logsContainer.innerHTML = logsHTML;
  }
  
  console.log('Site logs updated for child:', childHash, 'with', count, 'entries');
}

// Reset App Chart Dates to Last 30 Days
function resetAppChartDates(childHash) {
  const startDateInput = document.getElementById('startDate' + childHash);
  const endDateInput = document.getElementById('endDate' + childHash);
  
  if (startDateInput) startDateInput.value = '';
  if (endDateInput) endDateInput.value = '';
  
  // Reload charts with default data
  updateAppChart(childHash);
}

// Update App Analytics Section
function updateAppAnalytics(childHash, data) {
  const appAnalyticsDiv = document.getElementById('appAnalytics' + childHash);
  if (!appAnalyticsDiv) return;
  
  const totalTime = data.app_list.data.reduce((a, b) => a + b, 0);
  let analyticsHTML = '';
  
  if (data.app_list.labels[0] === 'No Data' || data.app_list.data.length === 0) {
    analyticsHTML = `
      <div class="text-center py-12">
        <svg class="w-16 h-16 mx-auto text-textsec/30 mb-3" fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 19v-6a2 2 0 00-2-2H5a2 2 0 00-2 2v6a2 2 0 002 2h2a2 2 0 002-2zm0 0V9a2 2 0 012-2h2a2 2 0 012 2v10m-6 0a2 2 0 002 2h2a2 2 0 002-2m0 0V5a2 2 0 012-2h2a2 2 0 012 2v14a2 2 0 01-2 2h-2a2 2 0 01-2-2z"></path>
        </svg>
        <p class="text-textsec text-sm">No application data available</p>
        <p class="text-textsec/60 text-xs mt-1">Data will appear once the child uses their device</p>
      </div>
    `;
    // Update total apps count
    const totalAppsCountEl = document.getElementById('totalAppsCount' + childHash);
    if (totalAppsCountEl) totalAppsCountEl.textContent = '0';
  } else {
    const totalTime = data.app_list.data.reduce((a, b) => a + b, 0);
    const maxTime = Math.max(...data.app_list.data);
    
    // Update total apps count
    const totalAppsCountEl = document.getElementById('totalAppsCount' + childHash);
    if (totalAppsCountEl) totalAppsCountEl.textContent = data.app_list.labels.length;
    
    // Show ALL apps (not just top 5)
    data.app_list.labels.forEach((app, index) => {
      const time = data.app_list.data[index];
      const icon = data.app_list.icons ? data.app_list.icons[index] : '';
      const domain = data.app_list.domains ? data.app_list.domains[index] : '';
      const percentage = ((time / totalTime) * 100).toFixed(1);
      const barWidth = (time / maxTime * 100).toFixed(1);
      const minutes = Math.round((time % 1) * 60);
      const hours = Math.floor(time);
      
      // Color variations - cycling through colors for all apps
      const colors = [
        { bg: 'bg-cyan-500/20', border: 'border-cyan-500/40', text: 'text-cyan-400', bar: 'bg-cyan-500' },
        { bg: 'bg-teal-500/20', border: 'border-teal-500/40', text: 'text-teal-400', bar: 'bg-teal-500' },
        { bg: 'bg-purple-500/20', border: 'border-purple-500/40', text: 'text-purple-400', bar: 'bg-purple-500' },
        { bg: 'bg-violet-500/20', border: 'border-violet-500/40', text: 'text-violet-400', bar: 'bg-violet-500' },
        { bg: 'bg-emerald-500/20', border: 'border-emerald-500/40', text: 'text-emerald-400', bar: 'bg-emerald-500' },
        { bg: 'bg-blue-500/20', border: 'border-blue-500/40', text: 'text-blue-400', bar: 'bg-blue-500' },
        { bg: 'bg-indigo-500/20', border: 'border-indigo-500/40', text: 'text-indigo-400', bar: 'bg-indigo-500' },
        { bg: 'bg-pink-500/20', border: 'border-pink-500/40', text: 'text-pink-400', bar: 'bg-pink-500' },
        { bg: 'bg-rose-500/20', border: 'border-rose-500/40', text: 'text-rose-400', bar: 'bg-rose-500' },
        { bg: 'bg-orange-500/20', border: 'border-orange-500/40', text: 'text-orange-400', bar: 'bg-orange-500' },
      ];
      const color = colors[index % colors.length];
      
      // Generate app icon HTML with better fallback
      const appIconHTML = (icon && icon.trim() !== '')
        ? `<div class="relative w-8 h-8 flex-shrink-0">
             <img src="${icon}" alt="${app}" class="w-8 h-8 rounded-lg object-cover" onerror="this.style.display='none'; this.nextElementSibling.style.display='flex';">
             <div class="w-8 h-8 ${color.bg} ${color.border} border rounded-lg flex items-center justify-center absolute inset-0" style="display: none;">
               <span class="text-xs font-bold ${color.text}">${app.charAt(0).toUpperCase()}</span>
             </div>
           </div>`
        : `<div class="w-8 h-8 ${color.bg} ${color.border} border rounded-lg flex items-center justify-center flex-shrink-0">
             <span class="text-xs font-bold ${color.text}">${app.charAt(0).toUpperCase()}</span>
           </div>`;
      
      analyticsHTML += `
        <div class="bg-black/30 border ${color.border} rounded-xl p-4 hover:bg-black/40 transition-all duration-300 group">
          <div class="flex items-start justify-between mb-3">
            <div class="flex-1 flex items-start gap-3">
              ${appIconHTML}
              <div class="flex-1 min-w-0">
                <h4 class="font-semibold text-textmain text-sm group-hover:${color.text} transition-colors mb-1 truncate">${app}</h4>
                <p class="text-xs text-textsec truncate font-mono">${domain || 'Unknown domain'}</p>
              </div>
            </div>
            <div class="text-right flex-shrink-0 ml-2">
              <p class="text-2xl font-bold ${color.text}">${hours}<span class="text-sm">h</span></p>
              ${minutes > 0 ? `<p class="text-xs text-textsec">${minutes}m</p>` : ''}
            </div>
          </div>
          
          <div class="relative">
            <div class="w-full bg-black/50 rounded-full h-2 overflow-hidden">
              <div class="${color.bar} h-2 rounded-full transition-all duration-1000 ease-out" 
                   style="width: ${barWidth}%"></div>
            </div>
            <div class="absolute -top-1 right-0 text-xs ${color.text} font-semibold opacity-0 group-hover:opacity-100 transition-opacity">
              ${time.toFixed(2)}h (${percentage}%)
            </div>
          </div>
        </div>
      `;
    });
  }
  
  appAnalyticsDiv.innerHTML = analyticsHTML;
}

// Mobile Sidebar Functions
function toggleMobileSidebar() {
  const sidebar = document.getElementById('sidebar');
  const overlay = document.querySelector('.mobile-sidebar-overlay');
  
  if (sidebar && overlay) {
    sidebar.classList.toggle('mobile-open');
    overlay.classList.toggle('active');
  }
}

function closeMobileSidebar() {
  const sidebar = document.getElementById('sidebar');
  const overlay = document.querySelector('.mobile-sidebar-overlay');
  
  if (sidebar && overlay) {
    sidebar.classList.remove('mobile-open');
    overlay.classList.remove('active');
  }
}

// Enhanced selectChild function with mobile support
const originalSelectChild = window.selectChild;
window.selectChild = function(childHash) {
  originalSelectChild(childHash);
  closeMobileSidebar();
}

// Initialize when DOM is loaded
document.addEventListener('DOMContentLoaded', function() {
  console.log('Dashboard scripts initialized');
  
  // Test if selectChild function is available
  if (typeof window.selectChild === 'function') {
    console.log('selectChild function is available');
  } else {
    console.error('selectChild function is not available');
  }
  
  // Check if child items exist
  const childItems = document.querySelectorAll('.child-item');
  console.log('Found', childItems.length, 'child items');
  
  // Initialize date inputs with last 30 days range
  initializeDateInputs();
  
  // Load restricted apps for all children on page load
  const restrictedAppsLists = document.querySelectorAll('[id^="restrictedAppsList"]');
  restrictedAppsLists.forEach(list => {
    const childHash = list.id.replace('restrictedAppsList', '');
    if (childHash) {
      loadRestrictedApps(childHash);
      // Initialize restrict button state
      updateRestrictButtonState(childHash);
    }
  });
});

// Initialize date inputs with default range (last 30 days)
function initializeDateInputs() {
  const today = new Date();
  const thirtyDaysAgo = new Date();
  thirtyDaysAgo.setDate(today.getDate() - 30);
  
  const endDateStr = today.toISOString().split('T')[0];
  const startDateStr = thirtyDaysAgo.toISOString().split('T')[0];
  
  // Set max date to today for all date inputs
  document.querySelectorAll('input[type="date"]').forEach(input => {
    input.setAttribute('max', endDateStr);
    
    // Set default values
    if (input.id.startsWith('startDate')) {
      input.value = startDateStr;
    } else if (input.id.startsWith('endDate')) {
      input.value = endDateStr;
    }
  });
}

// Add smooth scroll behavior
document.documentElement.style.scrollBehavior = 'smooth';

// ============================================
// BLOCKED APPS MANAGEMENT
// ============================================

// Autocomplete search state
let searchTimeout = null;
let currentSearchQuery = {};

// Debounced search function
function searchApps(childHash, query) {
    clearTimeout(searchTimeout);
    
    if (!query || query.trim().length < 2) {
        hideAppSuggestions(childHash);
        return;
    }

    searchTimeout = setTimeout(() => {
        performAppSearch(childHash, query.trim());
    }, 300); // 300ms debounce
}

// Perform actual search
async function performAppSearch(childHash, query) {
    const dropdown = document.getElementById('appSuggestions' + childHash);
    if (!dropdown) return;

    try {
        // Show loading state
        dropdown.innerHTML = `
            <div class="p-4 text-center text-textsec text-sm">
                <div class="inline-block animate-spin rounded-full h-6 w-6 border-b-2 border-primary mb-2"></div>
                <p>Searching apps...</p>
            </div>
        `;
        dropdown.classList.remove('hidden');

        const response = await fetch(`/api/apps/search/?q=${encodeURIComponent(query)}`, {
            method: 'GET',
            headers: {
                'Content-Type': 'application/json',
            }
        });

        if (!response.ok) {
            throw new Error('Search failed');
        }

        const data = await response.json();
        
        if (data.status === 'success' && data.apps && data.apps.length > 0) {
            renderAppSuggestions(childHash, data.apps);
        } else {
            dropdown.innerHTML = `
                <div class="p-4 text-center text-textsec text-sm">
                    <svg class="w-8 h-8 mx-auto mb-2 opacity-50" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z"></path>
                    </svg>
                    <p>No apps found matching "${query}"</p>
                </div>
            `;
        }
    } catch (error) {
        console.error('Error searching apps:', error);
        dropdown.innerHTML = `
            <div class="p-4 text-center text-red-400 text-sm">
                <p>Error searching apps. Please try again.</p>
            </div>
        `;
    }
}

// Render app suggestions in dropdown
function renderAppSuggestions(childHash, apps) {
    const dropdown = document.getElementById('appSuggestions' + childHash);
    if (!dropdown) return;

    dropdown.innerHTML = apps.map(app => `
        <div class="app-suggestion-item p-3 hover:bg-primary/10 cursor-pointer border-b border-textsec/10 last:border-0 transition-colors"
             onclick="selectAppSuggestion('${childHash}', '${app.domain.replace(/'/g, "\\'")}')">
            <div class="flex items-center gap-3">
                <div class="w-10 h-10 flex-shrink-0 bg-darkbg2 rounded-lg overflow-hidden flex items-center justify-center">
                    ${app.icon ? 
                        `<img src="${app.icon}" alt="${app.name}" class="w-full h-full object-cover" onerror="this.parentElement.innerHTML='<span class=\\'text-primary text-lg font-bold\\'>${app.name.charAt(0)}</span>'">` : 
                        `<span class="text-primary text-lg font-bold">${app.name.charAt(0)}</span>`
                    }
                </div>
                <div class="flex-1 min-w-0">
                    <p class="text-textmain font-medium text-sm truncate">${app.name}</p>
                    <p class="text-textsec text-xs font-mono truncate">${app.domain}</p>
                </div>
            </div>
        </div>
    `).join('');

    dropdown.classList.remove('hidden');
}

// Select app from suggestions
function selectAppSuggestion(childHash, domain) {
    const input = document.getElementById('newRestrictedApp' + childHash);
    if (input) {
        input.value = domain;
    }
    hideAppSuggestions(childHash);
}

// Show app suggestions (when input is focused)
function showAppSuggestions(childHash) {
    const input = document.getElementById('newRestrictedApp' + childHash);
    if (input && input.value.trim().length >= 2) {
        searchApps(childHash, input.value);
    }
}

// Hide app suggestions
function hideAppSuggestions(childHash) {
    const dropdown = document.getElementById('appSuggestions' + childHash);
    if (dropdown) {
        dropdown.classList.add('hidden');
    }
}

// Close dropdown when clicking outside
document.addEventListener('click', function(event) {
    const suggestions = document.querySelectorAll('[id^="appSuggestions"]');
    suggestions.forEach(dropdown => {
        const input = dropdown.previousElementSibling?.querySelector('input');
        if (!dropdown.contains(event.target) && event.target !== input) {
            dropdown.classList.add('hidden');
        }
    });
});

// Load restricted apps for a child
function loadRestrictedApps(childHash) {
  const restrictedAppsList = document.getElementById('restrictedAppsList' + childHash);
  const restrictedAppsCount = document.getElementById('restrictedAppsCount' + childHash);
  
  if (!restrictedAppsList) return;
  
  fetch('/api/blocked-apps/' + childHash + '/')
    .then(response => response.json())
    .then(data => {
      if (data.status === 'success') {
        const restrictedApps = data.restricted_apps || {};
        const appDomains = Object.keys(restrictedApps);
        
        // Update count
        if (restrictedAppsCount) {
          restrictedAppsCount.textContent = appDomains.length;
        }
        
        // Render restricted apps list
        if (appDomains.length === 0) {
          restrictedAppsList.innerHTML = `
            <div class="text-center py-8">
              <svg class="w-12 h-12 mx-auto text-textsec/30 mb-3" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z"></path>
              </svg>
              <p class="text-textsec text-sm">No restricted apps yet</p>
              <p class="text-textsec/60 text-xs mt-1">Add time limits for apps on the child's device</p>
            </div>
          `;
        } else {
          // Fetch app details for all restricted apps
          fetchAppDetailsForRestricted(childHash, restrictedApps);
        }
        
        // Update quick restrict buttons visibility
        updateQuickRestrictButtons(childHash, appDomains);
      }
    })
    .catch(error => {
      console.error('Error loading restricted apps:', error);
      restrictedAppsList.innerHTML = `
        <div class="text-center py-8">
          <svg class="w-12 h-12 mx-auto text-red-500/50 mb-3" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
          </svg>
          <p class="text-red-400 text-sm">Failed to load restricted apps</p>
        </div>
      `;
    });
}

// Fetch app details for restricted apps from search API
async function fetchAppDetailsForRestricted(childHash, restrictedApps) {
  const restrictedAppsList = document.getElementById('restrictedAppsList' + childHash);
  if (!restrictedAppsList) return;
  
  // Show loading state
  restrictedAppsList.innerHTML = `
    <div class="text-center py-8">
      <div class="inline-block animate-spin rounded-full h-8 w-8 border-b-2 border-primary mb-2"></div>
      <p class="text-textsec text-sm">Loading app details...</p>
    </div>
  `;
  
  try {
    // Fetch details for each app
    const appDetailsPromises = Object.entries(restrictedApps).map(async ([packageName, hours]) => {
      try {
        const response = await fetch(`/api/apps/search/?q=${encodeURIComponent(packageName)}`);
        const data = await response.json();
        
        if (data.status === 'success' && data.apps && data.apps.length > 0) {
          // Find exact match
          const exactMatch = data.apps.find(app => app.domain === packageName);
          if (exactMatch) {
            return {
              package_name: packageName,
              app_name: exactMatch.name,
              icon_url: exactMatch.icon,
              hours: hours
            };
          }
        }
        
        // Fallback if not found
        return {
          package_name: packageName,
          app_name: packageName.split('.').pop().charAt(0).toUpperCase() + packageName.split('.').pop().slice(1),
          icon_url: null,
          hours: hours
        };
      } catch (error) {
        console.error(`Error fetching details for ${packageName}:`, error);
        return {
          package_name: packageName,
          app_name: packageName.split('.').pop().charAt(0).toUpperCase() + packageName.split('.').pop().slice(1),
          icon_url: null,
          hours: hours
        };
      }
    });
    
    const restrictedAppsDetails = await Promise.all(appDetailsPromises);
    
    // Render the restricted apps list with fetched details
    renderRestrictedAppsList(childHash, restrictedAppsDetails);
  } catch (error) {
    console.error('Error fetching app details:', error);
    // Fallback to simple list
    const fallbackDetails = Object.entries(restrictedApps).map(([packageName, hours]) => ({
      package_name: packageName,
      app_name: packageName.split('.').pop().charAt(0).toUpperCase() + packageName.split('.').pop().slice(1),
      icon_url: null,
      hours: hours
    }));
    renderRestrictedAppsList(childHash, fallbackDetails);
  }
}

// Render restricted apps list with details
function renderRestrictedAppsList(childHash, restrictedAppsDetails) {
  const restrictedAppsList = document.getElementById('restrictedAppsList' + childHash);
  if (!restrictedAppsList) return;
  
  let appsHTML = '';
  restrictedAppsDetails.forEach((appDetail, index) => {
    const packageName = appDetail.package_name;
    const appName = appDetail.app_name;
    const iconUrl = appDetail.icon_url;
    const hours = appDetail.hours;
    
    // Check if blocked (0 hours)
    const isBlocked = hours === 0;
    
    // Format hours display
    const hoursDisplay = isBlocked ? 'Blocked' : `${hours}h/day`;
    const hoursColor = isBlocked ? 'text-gray-400' : 'text-amber-400';
    
    const colors = [
      'bg-amber-500/20 border-amber-500/40',
      'bg-orange-500/20 border-orange-500/40',
      'bg-yellow-500/20 border-yellow-500/40',
      'bg-lime-500/20 border-lime-500/40',
    ];
    const colorClass = isBlocked ? 'bg-gray-500/20 border-gray-500/40' : colors[index % colors.length];
    
    // Create icon element
    let iconElement = '';
    if (iconUrl) {
      iconElement = `
        <div class="w-10 h-10 flex-shrink-0 mr-3 bg-darkbg2 rounded-lg overflow-hidden flex items-center justify-center ${isBlocked ? 'opacity-50 grayscale' : ''}">
          <img src="${iconUrl}" alt="${appName}" class="w-full h-full object-cover" onerror="this.parentElement.innerHTML='<span class=\\'text-primary text-lg font-bold\\'>${appName.charAt(0)}</span>'">
        </div>
      `;
    } else {
      iconElement = `
        <div class="w-10 h-10 flex-shrink-0 mr-3 bg-darkbg2 rounded-lg overflow-hidden flex items-center justify-center ${isBlocked ? 'opacity-50' : ''}">
          <span class="text-primary text-lg font-bold">${appName.charAt(0)}</span>
        </div>
      `;
    }
    
    appsHTML += `
      <div class="flex items-center justify-between p-4 ${colorClass} border rounded-xl hover:bg-opacity-30 transition-all group">
        <div class="flex items-center flex-1 min-w-0">
          ${iconElement}
          <div class="flex-1 min-w-0">
            <div class="flex items-center gap-2 mb-1">
              <h4 class="font-semibold ${isBlocked ? 'text-gray-400' : 'text-textmain'} text-sm">${appName}</h4>
              <span class="text-xs ${hoursColor} font-bold px-2 py-0.5 bg-black/30 rounded">${hoursDisplay}</span>
            </div>
            <p class="text-xs ${isBlocked ? 'text-gray-500' : 'text-textsec/80'} font-mono truncate">${packageName}</p>
          </div>
        </div>
        <div class="flex items-center gap-2">
          ${isBlocked ? `
            <button 
              onclick="unblockApp('${childHash}', '${packageName}')"
              class="px-4 py-2 bg-green-500/20 hover:bg-green-500 border border-green-500/40 hover:border-green-500 text-green-400 hover:text-white rounded-lg transition-all duration-200 flex items-center gap-2 text-xs font-semibold"
              title="Unblock app"
            >
              <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 11V7a4 4 0 118 0m-4 8v2m-6 4h12a2 2 0 002-2v-6a2 2 0 00-2-2H6a2 2 0 00-2 2v6a2 2 0 002 2z"></path>
              </svg>
              Unblock
            </button>
          ` : `
            <input 
              type="number"
              id="editHours_${packageName.replace(/\./g, '_')}_${childHash}"
              value="${hours}"
              min="0"
              step="0.5"
              class="w-20 px-2 py-1 text-sm bg-darkbg1 border border-textsec/20 rounded text-textmain opacity-0 group-hover:opacity-100 transition-opacity"
              onchange="updateAppHours('${childHash}', '${packageName}', this.value)"
            />
          `}
          <button 
            onclick="removeRestrictedApp('${childHash}', '${packageName}')"
            class="px-3 py-2 bg-red-500/20 hover:bg-red-500 border border-red-500/40 hover:border-red-500 text-red-400 hover:text-white rounded-lg transition-all duration-200 flex items-center gap-2 text-xs font-semibold ${isBlocked ? '' : 'opacity-0 group-hover:opacity-100'}"
            title="Remove restriction"
          >
            <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
            </svg>
            Remove
          </button>
        </div>
      </div>
    `;
  });
  
  restrictedAppsList.innerHTML = appsHTML;
}

// Update quick restrict buttons visibility based on restricted apps
function updateQuickRestrictButtons(childHash, restrictedDomains) {
  const quickAddContainer = document.getElementById('quickAddButtons' + childHash);
  if (!quickAddContainer) return;
  
  const buttons = quickAddContainer.querySelectorAll('.quick-restrict-btn');
  buttons.forEach(button => {
    const packageName = button.getAttribute('data-package');
    if (restrictedDomains.includes(packageName)) {
      button.classList.add('hidden-restricted');
    } else {
      button.classList.remove('hidden-restricted');
    }
  });
}

// Update restrict button state based on hours value
function updateRestrictButtonState(childHash) {
  const hoursInput = document.getElementById('newAppHours' + childHash);
  const restrictBtn = document.getElementById('restrictBtn' + childHash);
  const restrictBtnIcon = document.getElementById('restrictBtnIcon' + childHash);
  const restrictBtnText = document.getElementById('restrictBtnText' + childHash);
  
  if (!hoursInput || !restrictBtn || !restrictBtnIcon || !restrictBtnText) return;
  
  const hours = parseFloat(hoursInput.value);
  
  if (hours === 0) {
    // Change to Block mode (red)
    restrictBtn.className = 'px-4 py-2 bg-gradient-to-r from-red-500 to-red-600 hover:from-red-600 hover:to-red-700 text-white font-semibold rounded-lg transition-all duration-200 flex items-center gap-2 shadow-lg hover:shadow-red-500/30 whitespace-nowrap';
    restrictBtnIcon.innerHTML = '<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M18.364 18.364A9 9 0 005.636 5.636m12.728 12.728A9 9 0 015.636 5.636m12.728 12.728L5.636 5.636"></path>';
    restrictBtnText.textContent = 'Block';
  } else {
    // Change to Restrict mode (amber)
    restrictBtn.className = 'px-4 py-2 bg-gradient-to-r from-amber-500 to-amber-600 hover:from-amber-600 hover:to-amber-700 text-white font-semibold rounded-lg transition-all duration-200 flex items-center gap-2 shadow-lg hover:shadow-amber-500/30 whitespace-nowrap';
    restrictBtnIcon.innerHTML = '<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z"></path>';
    restrictBtnText.textContent = 'Restrict';
  }
}

// Add a restricted app
function addRestrictedApp(childHash) {
  const input = document.getElementById('newRestrictedApp' + childHash);
  const hoursInput = document.getElementById('newAppHours' + childHash);
  const packageName = input.value.trim();
  const hours = parseFloat(hoursInput.value);
  
  if (!packageName) {
    showToast('Please enter an app package name', 'error');
    return;
  }
  
  // Basic validation for package name format
  if (!packageName.includes('.')) {
    showToast('Please enter a valid package name (e.g., com.example.app)', 'error');
    return;
  }
  
  if (isNaN(hours) || hours < 0) {
    showToast('Please enter a valid number of hours (0 or greater)', 'error');
    return;
  }
  
  // Get current restricted apps
  fetch('/api/blocked-apps/' + childHash + '/')
    .then(response => response.json())
    .then(data => {
      const restrictedApps = data.restricted_apps || {};
      
      // Check if already restricted
      if (packageName in restrictedApps) {
        showToast('This app is already restricted. Edit its time limit instead.', 'info');
        return;
      }
      
      // Add to object
      restrictedApps[packageName] = hours;
      
      // Update on server
      return updateRestrictedAppsOnServer(childHash, restrictedApps);
    })
    .then(success => {
      if (success) {
        input.value = ''; // Clear input
        hoursInput.value = '2'; // Reset to default
        loadRestrictedApps(childHash); // Reload list
        showToast('App restriction added successfully', 'success');
      }
    })
    .catch(error => {
      console.error('Error adding restricted app:', error);
      showToast('Failed to add restriction. Please try again.', 'error');
    });
}

// Quick restrict an app
function quickRestrictApp(childHash, packageName, appName, defaultHours) {
  fetch('/api/blocked-apps/' + childHash + '/')
    .then(response => response.json())
    .then(data => {
      const restrictedApps = data.restricted_apps || {};
      
      // Check if already restricted
      if (packageName in restrictedApps) {
        showToast(appName + ' is already restricted', 'info');
        return;
      }
      
      // Add to object
      restrictedApps[packageName] = defaultHours;
      
      // Update on server
      return updateRestrictedAppsOnServer(childHash, restrictedApps);
    })
    .then(success => {
      if (success) {
        loadRestrictedApps(childHash);
        showToast(appName + ` restricted to ${defaultHours}h/day`, 'success');
      }
    })
    .catch(error => {
      console.error('Error restricting app:', error);
      showToast('Failed to restrict ' + appName, 'error');
    });
}

// Update hours for an existing app
function updateAppHours(childHash, packageName, newHours) {
  const hours = parseFloat(newHours);
  
  if (isNaN(hours) || hours < 0) {
    showToast('Please enter a valid number of hours', 'error');
    return;
  }
  
  fetch('/api/blocked-apps/' + childHash + '/')
    .then(response => response.json())
    .then(data => {
      const restrictedApps = data.restricted_apps || {};
      
      // Update hours
      restrictedApps[packageName] = hours;
      
      // Update on server
      return updateRestrictedAppsOnServer(childHash, restrictedApps);
    })
    .then(success => {
      if (success) {
        loadRestrictedApps(childHash);
        showToast('Time limit updated successfully', 'success');
      }
    })
    .catch(error => {
      console.error('Error updating app hours:', error);
      showToast('Failed to update time limit', 'error');
    });
}

// Unblock an app (set hours to 1)
function unblockApp(childHash, packageName) {
  fetch('/api/blocked-apps/' + childHash + '/')
    .then(response => response.json())
    .then(data => {
      const restrictedApps = data.restricted_apps || {};
      
      // Set hours to 1
      restrictedApps[packageName] = 1;
      
      // Update on server
      return updateRestrictedAppsOnServer(childHash, restrictedApps);
    })
    .then(success => {
      if (success) {
        loadRestrictedApps(childHash);
        showToast('App unblocked - set to 1 hour/day', 'success');
      }
    })
    .catch(error => {
      console.error('Error unblocking app:', error);
      showToast('Failed to unblock app', 'error');
    });
}

// Remove a restricted app
function removeRestrictedApp(childHash, packageName) {

  fetch('/api/blocked-apps/' + childHash + '/')
    .then(response => response.json())
    .then(data => {
      const restrictedApps = data.restricted_apps || {};
      
      // Remove from object
      delete restrictedApps[packageName];
      
      // Update on server
      return updateRestrictedAppsOnServer(childHash, restrictedApps);
    })
    .then(success => {
      if (success) {
        loadRestrictedApps(childHash);
        showToast('Restriction removed successfully', 'success');
      }
    })
    .catch(error => {
      console.error('Error removing restricted app:', error);
      showToast('Failed to remove restriction. Please try again.', 'error');
    });
}

// Update restricted apps on server
function updateRestrictedAppsOnServer(childHash, restrictedApps) {
  return fetch('/api/blocked-apps/' + childHash + '/update/', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      'X-CSRFToken': getCookie('csrftoken')
    },
    body: JSON.stringify({
      restricted_apps: restrictedApps
    })
  })
  .then(response => response.json())
  .then(data => {
    if (data.status === 'success') {
      return true;
    } else {
      console.error('Server returned error:', data);
      showToast(data.error || 'Failed to update restrictions', 'error');
      return false;
    }
  })
  .catch(error => {
    console.error('Error updating restricted apps on server:', error);
    showToast('Failed to communicate with server', 'error');
    return false;
  });
}

// Helper function to get app name from package name
function getAppNameFromPackage(packageName) {
  const appNames = {
    'com.facebook.katana': 'Facebook',
    'com.instagram.android': 'Instagram',
    'com.whatsapp': 'WhatsApp',
    'com.snapchat.android': 'Snapchat',
    'com.zhiliaoapp.musically': 'TikTok',
    'com.twitter.android': 'Twitter/X',
    'com.google.android.youtube': 'YouTube',
    'com.netflix.mediaclient': 'Netflix',
    'com.spotify.music': 'Spotify',
    'com.reddit.frontpage': 'Reddit',
    'com.discord': 'Discord',
    'org.telegram.messenger': 'Telegram',
    'com.android.chrome': 'Chrome',
  };
  
  if (appNames[packageName]) {
    return appNames[packageName];
  }
  
  // Extract name from package (e.g., com.example.myapp -> Myapp)
  const parts = packageName.split('.');
  const lastPart = parts[parts.length - 1];
  return lastPart.charAt(0).toUpperCase() + lastPart.slice(1);
}

// Helper function to show toast notifications
function showToast(message, type = 'info') {
  const colors = {
    success: 'bg-green-500',
    error: 'bg-red-500',
    info: 'bg-cyan-500'
  };
  
  const toast = document.createElement('div');
  toast.className = `fixed bottom-4 right-4 ${colors[type]} text-white px-6 py-3 rounded-lg shadow-lg z-50 animate-fade-in-up`;
  toast.textContent = message;
  
  document.body.appendChild(toast);
  
  setTimeout(() => {
    toast.style.opacity = '0';
    toast.style.transform = 'translateY(10px)';
    toast.style.transition = 'all 0.3s ease';
    setTimeout(() => toast.remove(), 300);
  }, 3000);
}

// Get CSRF token from cookies
function getCookie(name) {
  let cookieValue = null;
  if (document.cookie && document.cookie !== '') {
    const cookies = document.cookie.split(';');
    for (let i = 0; i < cookies.length; i++) {
      const cookie = cookies[i].trim();
      if (cookie.substring(0, name.length + 1) === (name + '=')) {
        cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
        break;
      }
    }
  }
  return cookieValue;
}

// Load restricted apps when selecting a child
const originalSelectChildForRestricted = window.selectChild;
window.selectChild = function(childHash) {
  if (originalSelectChildForRestricted) {
    originalSelectChildForRestricted(childHash);
  }
  // Load restricted apps after a short delay to ensure dashboard is visible
  setTimeout(() => loadRestrictedApps(childHash), 300);
}

// Profile Image Upload Function
function uploadProfileImage(childHash, fileInput) {
  const file = fileInput.files[0];
  if (!file) {
    return;
  }
  
  // Client-side validation
  const maxSize = 5 * 1024 * 1024; // 5MB
  const allowedTypes = ['image/jpeg', 'image/jpg', 'image/png', 'image/gif', 'image/webp'];
  
  if (file.size > maxSize) {
    showToast('File size too large. Maximum size is 5MB.', 'error');
    fileInput.value = ''; // Clear the input
    return;
  }
  
  if (!allowedTypes.includes(file.type)) {
    showToast('Invalid file type. Please upload a JPG, PNG, GIF, or WEBP image.', 'error');
    fileInput.value = ''; // Clear the input
    return;
  }
  
  // Create FormData and upload
  const formData = new FormData();
  formData.append('profile_image', file);
  
  // Show loading state
  const profileDiv = document.querySelector(`[onclick*="${childHash}"]`);
  if (profileDiv) {
    profileDiv.style.opacity = '0.6';
    profileDiv.style.pointerEvents = 'none';
  }
  
  fetch(`/child/${childHash}/upload-profile-image/`, {
    method: 'POST',
    headers: {
      'X-CSRFToken': getCookie('csrftoken')
    },
    body: formData
  })
  .then(response => response.json())
  .then(data => {
    if (data.status === 'success') {
      // Update the profile image
      const profileImage = document.getElementById(`profileImage${childHash}`);
      const profileInitial = document.getElementById(`profileInitial${childHash}`);
      
      if (profileImage) {
        // Update existing image
        profileImage.src = data.image_url + '?t=' + new Date().getTime(); // Cache bust
      } else if (profileInitial) {
        // Replace initial with image
        const container = profileInitial.parentElement;
        container.innerHTML = `<img src="${data.image_url}" alt="Profile" class="w-full h-full object-cover" id="profileImage${childHash}">`;
      }
      
      showToast('Profile picture updated successfully!', 'success');
    } else {
      showToast(data.message || 'Failed to upload image', 'error');
    }
  })
  .catch(error => {
    console.error('Upload error:', error);
    showToast('An error occurred while uploading the image', 'error');
  })
  .finally(() => {
    // Restore state
    if (profileDiv) {
      profileDiv.style.opacity = '1';
      profileDiv.style.pointerEvents = 'auto';
    }
    fileInput.value = ''; // Clear the input for future uploads
  });
}

// AI Insights modal helpers
function openAIInsightsModal(childHash, childName) {
  const container = document.getElementById('aiModalContainer');
  if (!container) {
    console.error('AI modal container not found');
    return;
  }
  
  // Create modal HTML
  const modalHTML = `
    <div id="aiInsightsModal${childHash}" class="ai-modal-overlay" onclick="if(event.target === this) closeAIInsightsModal('${childHash}')">
      <div class="ai-modal-content p-6 relative" onclick="event.stopPropagation()">
        <button type="button" onclick="closeAIInsightsModal('${childHash}')" class="absolute top-4 right-4 text-textsec hover:text-white text-2xl font-bold w-10 h-10 flex items-center justify-center rounded-lg hover:bg-white/10 transition-all z-10">Ã—</button>
        
        <!-- Input Section -->
        <div id="aiInputSection${childHash}">
          <h3 class="text-xl font-bold text-textmain mb-1">AI Insights</h3>
          <p class="text-sm text-textsec mb-6">${childName}</p>
          
          <div class="space-y-4">
            <input id="aiInput${childHash}" type="text" placeholder="Ask AI questions about ${childName}'s activity..." class="w-full px-4 py-3 rounded-lg bg-black/40 border border-primary/30 text-textmain placeholder-textsec focus:outline-none focus:border-primary focus:ring-2 focus:ring-primary/20 transition-all" />

            <div class="flex flex-wrap gap-2">
              <button type="button" onclick="fillAIPreset('${childHash}','Summarise')" class="px-4 py-2 bg-primary/10 text-primary rounded-lg text-sm font-medium hover:bg-primary/20 border border-primary/30 hover:border-primary/50 transition-all">
                ðŸ“Š Summarise
              </button>
              <button type="button" onclick="fillAIPreset('${childHash}','Improvement ideas')" class="px-4 py-2 bg-primary/10 text-primary rounded-lg text-sm font-medium hover:bg-primary/20 border border-primary/30 hover:border-primary/50 transition-all">
                ðŸ’¡ Improvement ideas
              </button>
              <button type="button" onclick="fillAIPreset('${childHash}','Explain recent activity')" class="px-4 py-2 bg-primary/10 text-primary rounded-lg text-sm font-medium hover:bg-primary/20 border border-primary/30 hover:border-primary/50 transition-all">
                ðŸ” Explain recent activity
              </button>
            </div>

            <div class="flex items-center gap-3">
              <div id="aiStatus${childHash}" class="text-sm text-textsec flex-1"></div>
              <button type="button" onclick="sendAIQuestion('${childHash}')" class="inline-flex items-center gap-2 px-6 py-3 bg-primary text-darkbg1 rounded-lg font-semibold hover:bg-secondary transition-all shadow-lg hover:shadow-primary/30">
                <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 19l9 2-9-18-9 18 9-2zm0 0v-8"/>
                </svg>
                Send
              </button>
            </div>
          </div>
        </div>

        <!-- Response Section (hidden initially) -->
        <div id="aiResponseSection${childHash}" class="hidden">
          <div class="flex items-center justify-between mb-4">
            <h3 class="text-xl font-bold text-textmain">AI Analysis</h3>
            <button type="button" onclick="resetAIModal('${childHash}')" class="px-4 py-2 bg-primary/10 text-primary rounded-lg text-sm font-medium hover:bg-primary/20 border border-primary/30 hover:border-primary/50 transition-all">
              â†º New Question
            </button>
          </div>
          <div id="aiResponse${childHash}" class="p-4 rounded-lg bg-black/30 border border-primary/10 markdown-content ai-response-scroll" style="max-height: calc(90vh - 150px); overflow-y: auto;"></div>
        </div>
      </div>
    </div>
  `;
  
  container.innerHTML = modalHTML;
  
  // Focus input after a brief delay
  setTimeout(() => {
    const input = document.getElementById(`aiInput${childHash}`);
    if (input) input.focus();
  }, 100);
}

function closeAIInsightsModal(childHash) {
  const container = document.getElementById('aiModalContainer');
  if (container) {
    container.innerHTML = '';
  }
}

function fillAIPreset(childHash, text) {
  const input = document.getElementById('aiInput' + childHash);
  if (!input) return;
  input.value = text;
  input.focus();
}

async function sendAIQuestion(childHash) {
  const input = document.getElementById('aiInput' + childHash);
  const statusEl = document.getElementById('aiStatus' + childHash);
  const responseEl = document.getElementById('aiResponse' + childHash);
  const inputSection = document.getElementById('aiInputSection' + childHash);
  const responseSection = document.getElementById('aiResponseSection' + childHash);
  const sendBtn = event?.target?.closest('button');
  
  if (!input) return;
  const question = input.value.trim();
  if (!question) {
    showToast('Please enter a question', 'info');
    return;
  }
  
  // Disable send button and show loading state
  if (sendBtn) {
    sendBtn.disabled = true;
    sendBtn.classList.remove('bg-primary', 'hover:bg-secondary');
    sendBtn.classList.add('bg-gray-500', 'cursor-not-allowed', 'opacity-60');
    sendBtn.innerHTML = `
      <svg class="animate-spin h-4 w-4" fill="none" viewBox="0 0 24 24">
        <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
        <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
      </svg>
      Analysing...
    `;
  }
  
  if (responseEl) {
    responseEl.innerHTML = '<div class="flex items-center gap-2 text-textsec"><svg class="animate-spin h-5 w-5" fill="none" viewBox="0 0 24 24"><circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle><path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path></svg>Analyzing data...</div>';
  }

  try {
    const res = await fetch(`/api/child/${childHash}/ai-ask/`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'X-CSRFToken': getCookie('csrftoken')
      },
      body: JSON.stringify({ question })
    });

    const data = await res.json().catch(() => ({}));
    if (res.ok && data.status === 'success') {
      // Hide input section and show response section
      if (inputSection) inputSection.classList.add('hidden');
      if (responseSection) responseSection.classList.remove('hidden');
      
      if (responseEl) {
        // Parse markdown to HTML using marked.js
        const markdownText = data.answer || data.result || 'No answer returned';
        if (typeof marked !== 'undefined') {
          responseEl.innerHTML = marked.parse(markdownText);
        } else {
          // Fallback if marked.js not loaded
          responseEl.textContent = markdownText;
        }
      }
      showToast('AI analysis complete!', 'success');
    } else {
      if (responseEl) {
        responseEl.innerHTML = `<p class="text-red-400">âš ï¸ ${data.message || 'AI request failed'}</p>`;
      }
      showToast(data.message || 'AI request failed', 'error');
      
      // Re-enable button on error
      if (sendBtn) {
        sendBtn.disabled = false;
        sendBtn.classList.remove('bg-gray-500', 'cursor-not-allowed', 'opacity-60');
        sendBtn.classList.add('bg-primary', 'hover:bg-secondary');
        sendBtn.innerHTML = `
          <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 19l9 2-9-18-9 18 9-2zm0 0v-8"/>
          </svg>
          Send
        `;
      }
    }
  } catch (err) {
    console.error('AI request error:', err);
    if (responseEl) {
      responseEl.innerHTML = '<p class="text-red-400">âš ï¸ An error occurred sending the request.</p>';
    }
    showToast('Network error occurred', 'error');
    
    // Re-enable button on error
    if (sendBtn) {
      sendBtn.disabled = false;
      sendBtn.classList.remove('bg-gray-500', 'cursor-not-allowed', 'opacity-60');
      sendBtn.classList.add('bg-primary', 'hover:bg-secondary');
      sendBtn.innerHTML = `
        <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 19l9 2-9-18-9 18 9-2zm0 0v-8"/>
        </svg>
        Send
      `;
    }
  }
}

// Reset AI modal to input state
function resetAIModal(childHash) {
  const inputSection = document.getElementById('aiInputSection' + childHash);
  const responseSection = document.getElementById('aiResponseSection' + childHash);
  const input = document.getElementById('aiInput' + childHash);
  const responseEl = document.getElementById('aiResponse' + childHash);
  
  if (inputSection) inputSection.classList.remove('hidden');
  if (responseSection) responseSection.classList.add('hidden');
  if (input) {
    input.value = '';
    input.focus();
  }
  if (responseEl) responseEl.innerHTML = '';
}
</script>
