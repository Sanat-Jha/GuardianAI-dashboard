<script>
// Toggle Add Child Modal
function toggleAddChildModal() {
  const modal = document.getElementById('addChildModal');
  modal.classList.toggle('hidden');
}

// Close modal on outside click
document.getElementById('addChildModal')?.addEventListener('click', function(e) {
  if (e.target === this) {
    toggleAddChildModal();
  }
});

// Child Selection Logic for Sidebar
window.selectChild = function(childHash) {
  console.log('Selecting child:', childHash);
  
  // Update active state in sidebar
  document.querySelectorAll('.child-item').forEach(item => {
    item.classList.remove('active-child');
    const indicator = item.querySelector('.child-indicator');
    if (indicator) {
      indicator.style.opacity = '0';
    }
  });
  
  // Set active state for selected child
  const selectedItem = document.querySelector(`[data-child-hash="${childHash}"]`);
  if (selectedItem) {
    selectedItem.classList.add('active-child');
    const indicator = selectedItem.querySelector('.child-indicator');
    if (indicator) {
      indicator.style.opacity = '1';
    }
  }
  
  // Hide all child dashboards
  document.querySelectorAll('.child-dashboard').forEach(dash => {
    dash.classList.add('hidden');
  });
  
  // Show/hide select prompt
  const selectPrompt = document.getElementById('selectPrompt');
  if (childHash) {
    if (selectPrompt) selectPrompt.classList.add('hidden');
    
    // Show selected child dashboard
    const selectedDash = document.getElementById('child-' + childHash);
    if (selectedDash) {
      selectedDash.classList.remove('hidden');
      console.log('Showing dashboard for child:', childHash);
      
      // Load charts for this child
      loadChartsForChild(childHash);
    } else {
      console.error('Dashboard not found for child:', childHash);
    }
  } else {
    if (selectPrompt) selectPrompt.classList.remove('hidden');
  }
}

// Load Charts Function
function loadChartsForChild(childHash) {
  // Check if charts already exist
  const lineCanvas = document.getElementById('lineChart' + childHash);
  const barCanvas = document.getElementById('barChart' + childHash);
  const appAnalyticsDiv = document.getElementById('appAnalytics' + childHash);
  
  if (!lineCanvas || !barCanvas) {
    console.error('Chart canvases not found for child:', childHash);
    return;
  }
  
  // Fetch chart data
  fetch('/dashboard/chart-data/' + childHash + '/')
    .then(response => {
      if (!response.ok) {
        throw new Error('Network response was not ok: ' + response.statusText);
      }
      return response.json();
    })
    .then(data => {
      console.log('Chart data loaded:', data);
      
      // Destroy existing charts if any
      if (window.chartsInstances && window.chartsInstances[childHash]) {
        window.chartsInstances[childHash].line?.destroy();
        window.chartsInstances[childHash].bar?.destroy();
      }
      
      // Initialize charts storage
      if (!window.chartsInstances) window.chartsInstances = {};
      if (!window.chartsInstances[childHash]) window.chartsInstances[childHash] = {};
      
      // 1. LINE CHART - Screen Time Trend with Gradient
      const lineCtx = lineCanvas.getContext('2d');
      const gradient = lineCtx.createLinearGradient(0, 0, 0, 300);
      gradient.addColorStop(0, 'rgba(35, 210, 226, 0.3)');
      gradient.addColorStop(1, 'rgba(35, 210, 226, 0.0)');
      
      window.chartsInstances[childHash].line = new Chart(lineCtx, {
        type: 'line',
        data: {
          labels: data.line_chart.labels,
          datasets: [{
            label: 'Screen Time (hours)',
            data: data.line_chart.data,
            borderColor: '#23D2E2',
            backgroundColor: gradient,
            borderWidth: 3,
            fill: true,
            tension: 0.4,
            pointBackgroundColor: '#23D2E2',
            pointBorderColor: '#0F1B2A',
            pointBorderWidth: 3,
            pointRadius: 5,
            pointHoverRadius: 8,
            pointHoverBackgroundColor: '#8EF6FF',
            pointHoverBorderColor: '#FFFFFF',
            pointHoverBorderWidth: 3,
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          interaction: {
            intersect: false,
            mode: 'index'
          },
          plugins: {
            legend: {
              display: true,
              position: 'top',
              align: 'end',
              labels: { 
                color: '#A9B3C1', 
                font: { size: 12, weight: '600', family: 'Inter' },
                padding: 15,
                usePointStyle: true,
                pointStyle: 'circle'
              }
            },
            tooltip: {
              backgroundColor: 'rgba(15, 27, 42, 0.95)',
              titleColor: '#8EF6FF',
              bodyColor: '#FFFFFF',
              borderColor: '#23D2E2',
              borderWidth: 2,
              padding: 12,
              titleFont: { size: 14, weight: '700', family: 'Inter' },
              bodyFont: { size: 13, family: 'Inter' },
              displayColors: false,
              callbacks: {
                title: function(tooltipItems) {
                  return 'Date: ' + tooltipItems[0].label;
                },
                label: function(context) {
                  return 'Usage: ' + context.parsed.y.toFixed(2) + ' hours';
                }
              }
            }
          },
          scales: {
            y: {
              beginAtZero: true,
              ticks: { 
                color: '#A9B3C1', 
                font: { size: 11, family: 'Inter' },
                callback: function(value) {
                  return value + 'h';
                }
              },
              grid: { 
                color: 'rgba(169, 179, 193, 0.08)',
                drawBorder: false
              },
              border: { display: false }
            },
            x: {
              ticks: { 
                color: '#A9B3C1', 
                font: { size: 11, family: 'Inter' },
                maxRotation: 45,
                minRotation: 45
              },
              grid: { 
                display: false
              },
              border: { display: false }
            }
          }
        }
      });

      // 2. HORIZONTAL BAR CHART - App Usage Distribution (TOP 5 ONLY)
      const barCtx = barCanvas.getContext('2d');
      
      // Calculate total time from all apps
      const totalTime = data.app_list.data.reduce((a, b) => a + b, 0);
      document.getElementById('totalAppTime' + childHash).textContent = totalTime.toFixed(1) + 'h';
      
      window.chartsInstances[childHash].bar = new Chart(barCtx, {
        type: 'bar',
        data: {
          labels: data.bar_chart.labels,
          datasets: [{
            label: 'Usage (hours)',
            data: data.bar_chart.data,
            backgroundColor: [
              'rgba(35, 210, 226, 0.9)',
              'rgba(142, 246, 255, 0.9)',
              'rgba(24, 164, 180, 0.9)',
              'rgba(123, 108, 246, 0.9)',
              'rgba(184, 167, 255, 0.9)',
            ],
            borderColor: [
              '#23D2E2',
              '#8EF6FF',
              '#18A4B4',
              '#7B6CF6',
              '#B8A7FF',
            ],
            borderWidth: 2,
            borderRadius: 8,
            barThickness: 32,
          }]
        },
        options: {
          indexAxis: 'y',
          responsive: true,
          maintainAspectRatio: false,
          plugins: {
            legend: {
              display: false
            },
            tooltip: {
              backgroundColor: 'rgba(15, 27, 42, 0.95)',
              titleColor: '#8EF6FF',
              bodyColor: '#FFFFFF',
              borderColor: '#23D2E2',
              borderWidth: 2,
              padding: 12,
              titleFont: { size: 13, weight: '600', family: 'Inter' },
              bodyFont: { size: 12, family: 'Inter' },
              displayColors: true,
              callbacks: {
                label: function(context) {
                  const hours = context.parsed.x.toFixed(2);
                  const percentage = ((context.parsed.x / totalTime) * 100).toFixed(1);
                  return hours + 'h (' + percentage + '%)';
                }
              }
            }
          },
          scales: {
            x: {
              beginAtZero: true,
              ticks: { 
                color: '#A9B3C1', 
                font: { size: 11, family: 'Inter' },
                callback: function(value) {
                  return value + 'h';
                }
              },
              grid: { 
                color: 'rgba(169, 179, 193, 0.08)',
                drawBorder: false
              },
              border: { display: false }
            },
            y: {
              ticks: { 
                color: '#FFFFFF', 
                font: { size: 12, weight: '500', family: 'Inter' }
              },
              grid: { 
                display: false
              },
              border: { display: false }
            }
          }
        }
      });

      // 3. APPLICATION ANALYTICS - Interactive List (ALL APPS)
      if (appAnalyticsDiv) {
        let analyticsHTML = '';
        
        if (data.app_list.labels[0] === 'No Data' || data.app_list.data.length === 0) {
          analyticsHTML = `
            <div class="text-center py-12">
              <svg class="w-16 h-16 mx-auto text-textsec/30 mb-3" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 19v-6a2 2 0 00-2-2H5a2 2 0 00-2 2v6a2 2 0 002 2h2a2 2 0 002-2zm0 0V9a2 2 0 012-2h2a2 2 0 012 2v10m-6 0a2 2 0 002 2h2a2 2 0 002-2m0 0V5a2 2 0 012-2h2a2 2 0 012 2v14a2 2 0 01-2 2h-2a2 2 0 01-2-2z"></path>
              </svg>
              <p class="text-textsec text-sm">No application data available</p>
              <p class="text-textsec/60 text-xs mt-1">Data will appear once the child uses their device</p>
            </div>
          `;
          // Update total apps count
          const totalAppsCountEl = document.getElementById('totalAppsCount' + childHash);
          if (totalAppsCountEl) totalAppsCountEl.textContent = '0';
        } else {
          const maxTime = Math.max(...data.app_list.data);
          
          // Update total apps count
          const totalAppsCountEl = document.getElementById('totalAppsCount' + childHash);
          if (totalAppsCountEl) totalAppsCountEl.textContent = data.app_list.labels.length;
          
          // Show ALL apps (not just top 5)
          data.app_list.labels.forEach((app, index) => {
            const time = data.app_list.data[index];
            const icon = data.app_list.icons ? data.app_list.icons[index] : '';
            const domain = data.app_list.domains ? data.app_list.domains[index] : '';
            const percentage = ((time / totalTime) * 100).toFixed(1);
            const barWidth = (time / maxTime * 100).toFixed(1);
            const minutes = Math.round((time % 1) * 60);
            const hours = Math.floor(time);
            
            // Color variations - cycling through colors for all apps
            const colors = [
              { bg: 'bg-cyan-500/20', border: 'border-cyan-500/40', text: 'text-cyan-400', bar: 'bg-cyan-500' },
              { bg: 'bg-teal-500/20', border: 'border-teal-500/40', text: 'text-teal-400', bar: 'bg-teal-500' },
              { bg: 'bg-purple-500/20', border: 'border-purple-500/40', text: 'text-purple-400', bar: 'bg-purple-500' },
              { bg: 'bg-violet-500/20', border: 'border-violet-500/40', text: 'text-violet-400', bar: 'bg-violet-500' },
              { bg: 'bg-emerald-500/20', border: 'border-emerald-500/40', text: 'text-emerald-400', bar: 'bg-emerald-500' },
              { bg: 'bg-blue-500/20', border: 'border-blue-500/40', text: 'text-blue-400', bar: 'bg-blue-500' },
              { bg: 'bg-indigo-500/20', border: 'border-indigo-500/40', text: 'text-indigo-400', bar: 'bg-indigo-500' },
              { bg: 'bg-pink-500/20', border: 'border-pink-500/40', text: 'text-pink-400', bar: 'bg-pink-500' },
              { bg: 'bg-rose-500/20', border: 'border-rose-500/40', text: 'text-rose-400', bar: 'bg-rose-500' },
              { bg: 'bg-orange-500/20', border: 'border-orange-500/40', text: 'text-orange-400', bar: 'bg-orange-500' },
            ];
            const color = colors[index % colors.length];
            
            // Generate app icon HTML with better fallback
            const appIconHTML = (icon && icon.trim() !== '')
              ? `<div class="relative w-8 h-8 flex-shrink-0">
                   <img src="${icon}" alt="${app}" class="w-8 h-8 rounded-lg object-cover" onerror="this.style.display='none'; this.nextElementSibling.style.display='flex';">
                   <div class="w-8 h-8 ${color.bg} ${color.border} border rounded-lg flex items-center justify-center absolute inset-0" style="display: none;">
                     <span class="text-xs font-bold ${color.text}">${app.charAt(0).toUpperCase()}</span>
                   </div>
                 </div>`
              : `<div class="w-8 h-8 ${color.bg} ${color.border} border rounded-lg flex items-center justify-center flex-shrink-0">
                   <span class="text-xs font-bold ${color.text}">${app.charAt(0).toUpperCase()}</span>
                 </div>`;
            
            analyticsHTML += `
              <div class="bg-black/30 border ${color.border} rounded-xl p-4 hover:bg-black/40 transition-all duration-300 group">
                <div class="flex items-start justify-between mb-3">
                  <div class="flex-1 flex items-start gap-3">
                    ${appIconHTML}
                    <div class="flex-1 min-w-0">
                      <h4 class="font-semibold text-textmain text-sm group-hover:${color.text} transition-colors mb-1 truncate">${app}</h4>
                      <p class="text-xs text-textsec truncate font-mono">${domain || 'Unknown domain'}</p>
                    </div>
                  </div>
                  <div class="text-right flex-shrink-0 ml-2">
                    <p class="text-2xl font-bold ${color.text}">${hours}<span class="text-sm">h</span></p>
                    ${minutes > 0 ? `<p class="text-xs text-textsec">${minutes}m</p>` : ''}
                  </div>
                </div>
                
                <div class="relative">
                  <div class="w-full bg-black/50 rounded-full h-2 overflow-hidden">
                    <div class="${color.bar} h-2 rounded-full transition-all duration-1000 ease-out" 
                         style="width: ${barWidth}%"></div>
                  </div>
                  <div class="absolute -top-1 right-0 text-xs ${color.text} font-semibold opacity-0 group-hover:opacity-100 transition-opacity">
                    ${time.toFixed(2)}h (${percentage}%)
                  </div>
                </div>
              </div>
            `;
          });
        }
        
        appAnalyticsDiv.innerHTML = analyticsHTML;
      }
    })
    .catch(error => {
      console.error('Error loading chart data:', error);
      
      // Show error in all sections
      [lineCanvas, barCanvas].forEach(canvas => {
        if (canvas) {
          const ctx = canvas.getContext('2d');
          ctx.fillStyle = '#FF4D5A';
          ctx.font = '14px Inter';
          ctx.textAlign = 'center';
          ctx.fillText('âš  Error loading data', canvas.width / 2, canvas.height / 2 - 10);
          ctx.fillStyle = '#A9B3C1';
          ctx.font = '12px Inter';
          ctx.fillText('Please refresh the page', canvas.width / 2, canvas.height / 2 + 10);
        }
      });
      
      if (appAnalyticsDiv) {
        appAnalyticsDiv.innerHTML = `
          <div class="text-center py-12">
            <svg class="w-16 h-16 mx-auto text-red-500/50 mb-3" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z"></path>
            </svg>
            <p class="text-red-400 text-sm font-semibold">Failed to load analytics</p>
            <p class="text-textsec text-xs mt-2">Please refresh the page or try again later</p>
          </div>
        `;
      }
    });
}

// Update App Chart with Date Range
function updateAppChart(childHash) {
  const startDateInput = document.getElementById('startDate' + childHash);
  const endDateInput = document.getElementById('endDate' + childHash);
  const startDate = startDateInput?.value;
  const endDate = endDateInput?.value;
  
  // Build URL with date parameters
  let chartUrl = '/dashboard/chart-data/' + childHash + '/';
  let statsUrl = '/dashboard/stats/' + childHash + '/';
  let locationsUrl = '/dashboard/locations/' + childHash + '/';
  let siteLogsUrl = '/dashboard/site-logs/' + childHash + '/';
  const params = new URLSearchParams();
  
  if (startDate) {
    params.append('start_date', startDate);
  }
  if (endDate) {
    params.append('end_date', endDate);
  }
  
  if (params.toString()) {
    chartUrl += '?' + params.toString();
    statsUrl += '?' + params.toString();
    locationsUrl += '?' + params.toString();
    siteLogsUrl += '?' + params.toString();
  }
  
  console.log('Fetching chart data with dates:', chartUrl);
  console.log('Fetching stats data with dates:', statsUrl);
  console.log('Fetching locations data with dates:', locationsUrl);
  console.log('Fetching site logs data with dates:', siteLogsUrl);
  
  // Fetch chart data, stats data, locations data, and site logs data in parallel
  Promise.all([
    fetch(chartUrl).then(res => {
      if (!res.ok) throw new Error('Chart data fetch failed');
      return res.json();
    }),
    fetch(statsUrl).then(res => {
      if (!res.ok) throw new Error('Stats data fetch failed');
      return res.json();
    }),
    fetch(locationsUrl).then(res => {
      if (!res.ok) throw new Error('Locations data fetch failed');
      return res.json();
    }),
    fetch(siteLogsUrl).then(res => {
      if (!res.ok) throw new Error('Site logs fetch failed');
      return res.json();
    })
  ])
    .then(([chartData, statsData, locationsData, siteLogsData]) => {
      console.log('Updated chart data loaded:', chartData);
      console.log('Updated stats data loaded:', statsData);
      console.log('Updated locations data loaded:', locationsData);
      console.log('Updated site logs data loaded:', siteLogsData);
      
      // Update line chart
      if (window.chartsInstances && window.chartsInstances[childHash]) {
        // Update line chart data
        if (window.chartsInstances[childHash].line) {
          window.chartsInstances[childHash].line.data.labels = chartData.line_chart.labels;
          window.chartsInstances[childHash].line.data.datasets[0].data = chartData.line_chart.data;
          window.chartsInstances[childHash].line.update();
        }
        
        // Update bar chart data (TOP 5 ONLY)
        if (window.chartsInstances[childHash].bar) {
          window.chartsInstances[childHash].bar.data.labels = chartData.bar_chart.labels;
          window.chartsInstances[childHash].bar.data.datasets[0].data = chartData.bar_chart.data;
          window.chartsInstances[childHash].bar.update();
          
          // Update total time display (from all apps)
          const totalTime = chartData.app_list.data.reduce((a, b) => a + b, 0);
          document.getElementById('totalAppTime' + childHash).textContent = totalTime.toFixed(1) + 'h';
        }
        
        // Update app analytics if present
        updateAppAnalytics(childHash, chartData);
      }
      
      // Update stat cards
      updateStatCards(childHash, statsData.stats);
      
      // Update location map
      updateLocationMap(childHash, locationsData.locations, locationsData.count);
      
      // Update site logs
      updateSiteLogs(childHash, siteLogsData.site_logs, siteLogsData.count);
    })
    .catch(error => {
      console.error('Error loading data:', error);
      alert('Failed to load data. Please try again.');
    });
}

// Update Stat Cards with new data
function updateStatCards(childHash, stats) {
  // Update Total Screen Time
  const totalStatCard = document.getElementById('stat-total-' + childHash);
  if (totalStatCard) {
    const valueEl = totalStatCard.querySelector('.stat-value');
    if (valueEl) {
      // Add animation class
      valueEl.classList.add('animate-pulse');
      valueEl.textContent = stats.total_screen_time_hours;
      setTimeout(() => valueEl.classList.remove('animate-pulse'), 1000);
    }
  }
  
  // Update Average Daily
  const avgStatCard = document.getElementById('stat-avg-' + childHash);
  if (avgStatCard) {
    const valueEl = avgStatCard.querySelector('.stat-value');
    if (valueEl) {
      valueEl.classList.add('animate-pulse');
      valueEl.textContent = stats.avg_screen_time_formatted;
      setTimeout(() => valueEl.classList.remove('animate-pulse'), 1000);
    }
  }
  
  // Update Latest Location
  const locationStatCard = document.getElementById('stat-location-' + childHash);
  if (locationStatCard) {
    const valueEl = locationStatCard.querySelector('.stat-value');
    if (valueEl) {
      valueEl.classList.add('animate-pulse');
      valueEl.textContent = stats.latest_location;
      setTimeout(() => valueEl.classList.remove('animate-pulse'), 1000);
    }
  }
  
  // Update Blocked Sites
  const blockStatCard = document.getElementById('stat-block-' + childHash);
  if (blockStatCard) {
    const valueEl = blockStatCard.querySelector('.stat-value');
    const subtitleEl = blockStatCard.querySelector('.stat-subtitle');
    if (valueEl) {
      valueEl.classList.add('animate-pulse');
      valueEl.textContent = stats.blocked_sites;
      setTimeout(() => valueEl.classList.remove('animate-pulse'), 1000);
    }
    if (subtitleEl) {
      subtitleEl.textContent = stats.site_access_count + ' total sites';
    }
  }
  
  console.log('Stat cards updated for child:', childHash);
}

// Update Location Map with new data
function updateLocationMap(childHash, locations, count) {
  const locationSection = document.getElementById('location-section-' + childHash);
  if (!locationSection) return;
  
  // Update location count badge
  const countBadge = locationSection.querySelector('.location-count-badge');
  if (countBadge) {
    countBadge.innerHTML = `${count} <span class="text-xs text-textsec font-normal">entries</span>`;
  }
  
  // Update location data
  if (window.locationData) {
    window.locationData[childHash] = locations;
  }
  
  const mapContainer = locationSection.querySelector('.location-map-container');
  if (!mapContainer) return;
  
  if (locations.length === 0) {
    // Show no data message
    mapContainer.innerHTML = `
      <div class="text-center py-12 no-location-message">
        <svg class="w-16 h-16 mx-auto text-textsec/30 mb-3" fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M17.657 16.657L13.414 20.9a1.998 1.998 0 01-2.827 0l-4.244-4.243a8 8 0 1111.314 0z"></path>
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 11a3 3 0 11-6 0 3 3 0 016 0z"></path>
        </svg>
        <p class="text-textsec text-sm font-medium">No location data for selected date range</p>
        <p class="text-textsec/60 text-xs mt-1">Try selecting a different date range</p>
      </div>
    `;
  } else {
    // Destroy existing map if it exists
    if (window.locationMaps && window.locationMaps[childHash]) {
      window.locationMaps[childHash].remove();
      delete window.locationMaps[childHash];
    }
    
    // Clear markers
    if (window.locationMarkers && window.locationMarkers[childHash]) {
      window.locationMarkers[childHash] = [];
    }
    
    // Recreate map container and controls
    mapContainer.innerHTML = `
      <div id="location-map-${childHash}"></div>
      <div class="map-controls">
        <button class="control-btn" onclick="fitAllMarkers('${childHash}')">
          <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 8V4m0 0h4M4 4l5 5m11-1V4m0 0h-4m4 0l-5 5M4 16v4m0 0h4m-4 0l5-5m11 5l-5-5m5 5v-4m0 4h-4"></path>
          </svg>
          Fit All
        </button>
        <button class="control-btn" onclick="togglePath('${childHash}')">
          <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 10V3L4 14h7v7l9-11h-7z"></path>
          </svg>
          Toggle Path
        </button>
        <button class="control-btn" onclick="showFirstLocation('${childHash}')">
          <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 12l2-2m0 0l7-7 7 7M5 10v10a1 1 0 001 1h3m10-11l2 2m-2-2v10a1 1 0 01-1 1h-3m-6 0a1 1 0 001-1v-4a1 1 0 011-1h2a1 1 0 011 1v4a1 1 0 001 1m-6 0h6"></path>
          </svg>
          First Location
        </button>
        <button class="control-btn" onclick="showLastLocation('${childHash}')">
          <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M17 8l4 4m0 0l-4 4m4-4H3"></path>
          </svg>
          Latest Location
        </button>
      </div>
    `;
    
    // Reinitialize map with new data
    setTimeout(() => {
      if (typeof initLocationMap === 'function') {
        initLocationMap(childHash);
        // Force map to recalculate size after initialization
        setTimeout(() => {
          if (window.locationMaps && window.locationMaps[childHash]) {
            window.locationMaps[childHash].invalidateSize();
          }
        }, 200);
      }
    }, 100);
  }
  
  console.log('Location map updated for child:', childHash, 'with', count, 'locations');
}

// Update Site Access Logs with new data
function updateSiteLogs(childHash, siteLogs, count) {
  const siteSection = document.getElementById('site-section-' + childHash);
  if (!siteSection) return;
  
  // Update site count badge
  const countBadge = siteSection.querySelector('.site-count-badge');
  if (countBadge) {
    countBadge.innerHTML = `${count} <span class="text-xs text-textsec font-normal">entries</span>`;
  }
  
  const logsContainer = siteSection.querySelector('.site-logs-container');
  if (!logsContainer) return;
  
  if (siteLogs.length === 0) {
    // Show no data message
    logsContainer.innerHTML = `
      <div class="text-center py-12">
        <svg class="w-16 h-16 mx-auto text-textsec/30 mb-3" fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 12a9 9 0 01-9 9m9-9a9 9 0 00-9-9m9 9H3m9 9a9 9 0 01-9-9m9 9c1.657 0 3-4.03 3-9s-1.343-9-3-9m0 18c-1.657 0-3-4.03-3-9s1.343-9 3-9m-9 9a9 9 0 019-9"></path>
        </svg>
        <p class="text-textsec text-sm font-medium">No site access data for selected date range</p>
        <p class="text-textsec/60 text-xs mt-1">Try selecting a different date range</p>
      </div>
    `;
  } else {
    // Rebuild site logs list
    let logsHTML = '';
    siteLogs.forEach(log => {
      const accessed = log.accessed;
      const statusColor = accessed ? 'lime' : 'red';
      const statusLabel = accessed ? 'ACCESSED' : 'BLOCKED';
      const statusIcon = accessed 
        ? '<svg class="w-3 h-3 inline mr-1" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7"></path></svg>'
        : '<svg class="w-3 h-3 inline mr-1" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg>';
      
      // Parse timestamp to readable format
      const timestamp = new Date(log.timestamp);
      const formattedDate = timestamp.toLocaleDateString('en-US', { 
        month: 'short', 
        day: 'numeric', 
        year: 'numeric' 
      }) + ' ' + timestamp.toLocaleTimeString('en-US', {
        hour: '2-digit',
        minute: '2-digit'
      });
      
      logsHTML += `
        <div class="relative bg-gradient-to-r from-black/40 to-black/20 rounded-lg p-4 border border-${statusColor}-500/20 hover:border-${statusColor}-500/40 transition-all duration-300 group/item">
          <!-- Left accent bar -->
          <div class="absolute left-0 top-0 bottom-0 w-1 bg-gradient-to-b from-${statusColor}-500 to-${statusColor}-600 rounded-l-lg"></div>
          
          <div class="flex flex-col gap-3 ml-2">
            <div class="flex items-center justify-between gap-4">
              <div class="flex items-center gap-2">
                <svg class="w-4 h-4 text-${statusColor}-400 flex-shrink-0" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 7V3m8 4V3m-9 8h10M5 21h14a2 2 0 002-2V7a2 2 0 00-2-2H5a2 2 0 00-2 2v12a2 2 0 002 2z"></path>
                </svg>
                <span class="text-textmain text-sm font-medium">${formattedDate}</span>
              </div>
              <span class="font-bold text-xs px-3 py-1 rounded-lg bg-${statusColor}-500/10 text-${statusColor}-400 border border-${statusColor}-500/30 shadow-lg">
                ${statusIcon}
                ${statusLabel}
              </span>
            </div>
            
            <div class="flex items-start gap-2 bg-black/50 p-3 rounded-lg border border-primary/10">
              <svg class="w-4 h-4 text-primary flex-shrink-0 mt-0.5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13.828 10.172a4 4 0 00-5.656 0l-4 4a4 4 0 105.656 5.656l1.102-1.101m-.758-4.899a4 4 0 005.656 0l4-4a4 4 0 00-5.656-5.656l-1.1 1.1"></path>
              </svg>
              <span class="break-all text-textsec text-sm font-mono leading-relaxed">${log.url}</span>
            </div>
          </div>
        </div>
      `;
    });
    
    logsContainer.innerHTML = logsHTML;
  }
  
  console.log('Site logs updated for child:', childHash, 'with', count, 'entries');
}

// Reset App Chart Dates to Last 30 Days
function resetAppChartDates(childHash) {
  const startDateInput = document.getElementById('startDate' + childHash);
  const endDateInput = document.getElementById('endDate' + childHash);
  
  if (startDateInput) startDateInput.value = '';
  if (endDateInput) endDateInput.value = '';
  
  // Reload charts with default data
  updateAppChart(childHash);
}

// Update App Analytics Section
function updateAppAnalytics(childHash, data) {
  const appAnalyticsDiv = document.getElementById('appAnalytics' + childHash);
  if (!appAnalyticsDiv) return;
  
  const totalTime = data.app_list.data.reduce((a, b) => a + b, 0);
  let analyticsHTML = '';
  
  if (data.app_list.labels[0] === 'No Data' || data.app_list.data.length === 0) {
    analyticsHTML = `
      <div class="text-center py-12">
        <svg class="w-16 h-16 mx-auto text-textsec/30 mb-3" fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 19v-6a2 2 0 00-2-2H5a2 2 0 00-2 2v6a2 2 0 002 2h2a2 2 0 002-2zm0 0V9a2 2 0 012-2h2a2 2 0 012 2v10m-6 0a2 2 0 002 2h2a2 2 0 002-2m0 0V5a2 2 0 012-2h2a2 2 0 012 2v14a2 2 0 01-2 2h-2a2 2 0 01-2-2z"></path>
        </svg>
        <p class="text-textsec text-sm">No application data available</p>
        <p class="text-textsec/60 text-xs mt-1">Data will appear once the child uses their device</p>
      </div>
    `;
    // Update total apps count
    const totalAppsCountEl = document.getElementById('totalAppsCount' + childHash);
    if (totalAppsCountEl) totalAppsCountEl.textContent = '0';
  } else {
    const totalTime = data.app_list.data.reduce((a, b) => a + b, 0);
    const maxTime = Math.max(...data.app_list.data);
    
    // Update total apps count
    const totalAppsCountEl = document.getElementById('totalAppsCount' + childHash);
    if (totalAppsCountEl) totalAppsCountEl.textContent = data.app_list.labels.length;
    
    // Show ALL apps (not just top 5)
    data.app_list.labels.forEach((app, index) => {
      const time = data.app_list.data[index];
      const icon = data.app_list.icons ? data.app_list.icons[index] : '';
      const domain = data.app_list.domains ? data.app_list.domains[index] : '';
      const percentage = ((time / totalTime) * 100).toFixed(1);
      const barWidth = (time / maxTime * 100).toFixed(1);
      const minutes = Math.round((time % 1) * 60);
      const hours = Math.floor(time);
      
      // Color variations - cycling through colors for all apps
      const colors = [
        { bg: 'bg-cyan-500/20', border: 'border-cyan-500/40', text: 'text-cyan-400', bar: 'bg-cyan-500' },
        { bg: 'bg-teal-500/20', border: 'border-teal-500/40', text: 'text-teal-400', bar: 'bg-teal-500' },
        { bg: 'bg-purple-500/20', border: 'border-purple-500/40', text: 'text-purple-400', bar: 'bg-purple-500' },
        { bg: 'bg-violet-500/20', border: 'border-violet-500/40', text: 'text-violet-400', bar: 'bg-violet-500' },
        { bg: 'bg-emerald-500/20', border: 'border-emerald-500/40', text: 'text-emerald-400', bar: 'bg-emerald-500' },
        { bg: 'bg-blue-500/20', border: 'border-blue-500/40', text: 'text-blue-400', bar: 'bg-blue-500' },
        { bg: 'bg-indigo-500/20', border: 'border-indigo-500/40', text: 'text-indigo-400', bar: 'bg-indigo-500' },
        { bg: 'bg-pink-500/20', border: 'border-pink-500/40', text: 'text-pink-400', bar: 'bg-pink-500' },
        { bg: 'bg-rose-500/20', border: 'border-rose-500/40', text: 'text-rose-400', bar: 'bg-rose-500' },
        { bg: 'bg-orange-500/20', border: 'border-orange-500/40', text: 'text-orange-400', bar: 'bg-orange-500' },
      ];
      const color = colors[index % colors.length];
      
      // Generate app icon HTML with better fallback
      const appIconHTML = (icon && icon.trim() !== '')
        ? `<div class="relative w-8 h-8 flex-shrink-0">
             <img src="${icon}" alt="${app}" class="w-8 h-8 rounded-lg object-cover" onerror="this.style.display='none'; this.nextElementSibling.style.display='flex';">
             <div class="w-8 h-8 ${color.bg} ${color.border} border rounded-lg flex items-center justify-center absolute inset-0" style="display: none;">
               <span class="text-xs font-bold ${color.text}">${app.charAt(0).toUpperCase()}</span>
             </div>
           </div>`
        : `<div class="w-8 h-8 ${color.bg} ${color.border} border rounded-lg flex items-center justify-center flex-shrink-0">
             <span class="text-xs font-bold ${color.text}">${app.charAt(0).toUpperCase()}</span>
           </div>`;
      
      analyticsHTML += `
        <div class="bg-black/30 border ${color.border} rounded-xl p-4 hover:bg-black/40 transition-all duration-300 group">
          <div class="flex items-start justify-between mb-3">
            <div class="flex-1 flex items-start gap-3">
              ${appIconHTML}
              <div class="flex-1 min-w-0">
                <h4 class="font-semibold text-textmain text-sm group-hover:${color.text} transition-colors mb-1 truncate">${app}</h4>
                <p class="text-xs text-textsec truncate font-mono">${domain || 'Unknown domain'}</p>
              </div>
            </div>
            <div class="text-right flex-shrink-0 ml-2">
              <p class="text-2xl font-bold ${color.text}">${hours}<span class="text-sm">h</span></p>
              ${minutes > 0 ? `<p class="text-xs text-textsec">${minutes}m</p>` : ''}
            </div>
          </div>
          
          <div class="relative">
            <div class="w-full bg-black/50 rounded-full h-2 overflow-hidden">
              <div class="${color.bar} h-2 rounded-full transition-all duration-1000 ease-out" 
                   style="width: ${barWidth}%"></div>
            </div>
            <div class="absolute -top-1 right-0 text-xs ${color.text} font-semibold opacity-0 group-hover:opacity-100 transition-opacity">
              ${time.toFixed(2)}h (${percentage}%)
            </div>
          </div>
        </div>
      `;
    });
  }
  
  appAnalyticsDiv.innerHTML = analyticsHTML;
}

// Mobile Sidebar Functions
function toggleMobileSidebar() {
  const sidebar = document.getElementById('sidebar');
  const overlay = document.querySelector('.mobile-sidebar-overlay');
  
  if (sidebar && overlay) {
    sidebar.classList.toggle('mobile-open');
    overlay.classList.toggle('active');
  }
}

function closeMobileSidebar() {
  const sidebar = document.getElementById('sidebar');
  const overlay = document.querySelector('.mobile-sidebar-overlay');
  
  if (sidebar && overlay) {
    sidebar.classList.remove('mobile-open');
    overlay.classList.remove('active');
  }
}

// Enhanced selectChild function with mobile support
const originalSelectChild = window.selectChild;
window.selectChild = function(childHash) {
  originalSelectChild(childHash);
  closeMobileSidebar();
}

// Initialize when DOM is loaded
document.addEventListener('DOMContentLoaded', function() {
  console.log('Dashboard scripts initialized');
  
  // Test if selectChild function is available
  if (typeof window.selectChild === 'function') {
    console.log('selectChild function is available');
  } else {
    console.error('selectChild function is not available');
  }
  
  // Check if child items exist
  const childItems = document.querySelectorAll('.child-item');
  console.log('Found', childItems.length, 'child items');
  
  // Initialize date inputs with last 30 days range
  initializeDateInputs();
});

// Initialize date inputs with default range (last 30 days)
function initializeDateInputs() {
  const today = new Date();
  const thirtyDaysAgo = new Date();
  thirtyDaysAgo.setDate(today.getDate() - 30);
  
  const endDateStr = today.toISOString().split('T')[0];
  const startDateStr = thirtyDaysAgo.toISOString().split('T')[0];
  
  // Set max date to today for all date inputs
  document.querySelectorAll('input[type="date"]').forEach(input => {
    input.setAttribute('max', endDateStr);
    
    // Set default values
    if (input.id.startsWith('startDate')) {
      input.value = startDateStr;
    } else if (input.id.startsWith('endDate')) {
      input.value = endDateStr;
    }
  });
}

// Add smooth scroll behavior
document.documentElement.style.scrollBehavior = 'smooth';

// ============================================
// BLOCKED APPS MANAGEMENT
// ============================================

// Autocomplete search state
let searchTimeout = null;
let currentSearchQuery = {};

// Debounced search function
function searchApps(childHash, query) {
    clearTimeout(searchTimeout);
    
    if (!query || query.trim().length < 2) {
        hideAppSuggestions(childHash);
        return;
    }

    searchTimeout = setTimeout(() => {
        performAppSearch(childHash, query.trim());
    }, 300); // 300ms debounce
}

// Perform actual search
async function performAppSearch(childHash, query) {
    const dropdown = document.getElementById('appSuggestions' + childHash);
    if (!dropdown) return;

    try {
        // Show loading state
        dropdown.innerHTML = `
            <div class="p-4 text-center text-textsec text-sm">
                <div class="inline-block animate-spin rounded-full h-6 w-6 border-b-2 border-primary mb-2"></div>
                <p>Searching apps...</p>
            </div>
        `;
        dropdown.classList.remove('hidden');

        const response = await fetch(`/api/apps/search/?q=${encodeURIComponent(query)}`, {
            method: 'GET',
            headers: {
                'Content-Type': 'application/json',
            }
        });

        if (!response.ok) {
            throw new Error('Search failed');
        }

        const data = await response.json();
        
        if (data.status === 'success' && data.apps && data.apps.length > 0) {
            renderAppSuggestions(childHash, data.apps);
        } else {
            dropdown.innerHTML = `
                <div class="p-4 text-center text-textsec text-sm">
                    <svg class="w-8 h-8 mx-auto mb-2 opacity-50" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z"></path>
                    </svg>
                    <p>No apps found matching "${query}"</p>
                </div>
            `;
        }
    } catch (error) {
        console.error('Error searching apps:', error);
        dropdown.innerHTML = `
            <div class="p-4 text-center text-red-400 text-sm">
                <p>Error searching apps. Please try again.</p>
            </div>
        `;
    }
}

// Render app suggestions in dropdown
function renderAppSuggestions(childHash, apps) {
    const dropdown = document.getElementById('appSuggestions' + childHash);
    if (!dropdown) return;

    dropdown.innerHTML = apps.map(app => `
        <div class="app-suggestion-item p-3 hover:bg-primary/10 cursor-pointer border-b border-textsec/10 last:border-0 transition-colors"
             onclick="selectAppSuggestion('${childHash}', '${app.domain.replace(/'/g, "\\'")}')">
            <div class="flex items-center gap-3">
                <div class="w-10 h-10 flex-shrink-0 bg-darkbg2 rounded-lg overflow-hidden flex items-center justify-center">
                    ${app.icon ? 
                        `<img src="${app.icon}" alt="${app.name}" class="w-full h-full object-cover" onerror="this.parentElement.innerHTML='<span class=\\'text-primary text-lg font-bold\\'>${app.name.charAt(0)}</span>'">` : 
                        `<span class="text-primary text-lg font-bold">${app.name.charAt(0)}</span>`
                    }
                </div>
                <div class="flex-1 min-w-0">
                    <p class="text-textmain font-medium text-sm truncate">${app.name}</p>
                    <p class="text-textsec text-xs font-mono truncate">${app.domain}</p>
                </div>
            </div>
        </div>
    `).join('');

    dropdown.classList.remove('hidden');
}

// Select app from suggestions
function selectAppSuggestion(childHash, domain) {
    const input = document.getElementById('newBlockedApp' + childHash);
    if (input) {
        input.value = domain;
    }
    hideAppSuggestions(childHash);
}

// Show app suggestions (when input is focused)
function showAppSuggestions(childHash) {
    const input = document.getElementById('newBlockedApp' + childHash);
    if (input && input.value.trim().length >= 2) {
        searchApps(childHash, input.value);
    }
}

// Hide app suggestions
function hideAppSuggestions(childHash) {
    const dropdown = document.getElementById('appSuggestions' + childHash);
    if (dropdown) {
        dropdown.classList.add('hidden');
    }
}

// Close dropdown when clicking outside
document.addEventListener('click', function(event) {
    const suggestions = document.querySelectorAll('[id^="appSuggestions"]');
    suggestions.forEach(dropdown => {
        const input = dropdown.previousElementSibling?.querySelector('input');
        if (!dropdown.contains(event.target) && event.target !== input) {
            dropdown.classList.add('hidden');
        }
    });
});

// Load blocked apps for a child
function loadBlockedApps(childHash) {
  const blockedAppsList = document.getElementById('blockedAppsList' + childHash);
  const blockedAppsCount = document.getElementById('blockedAppsCount' + childHash);
  
  if (!blockedAppsList) return;
  
  fetch('/api/blocked-apps/' + childHash + '/')
    .then(response => response.json())
    .then(data => {
      if (data.status === 'success') {
        const blockedApps = data.blocked_apps || [];
        
        // Update count
        if (blockedAppsCount) {
          blockedAppsCount.textContent = blockedApps.length;
        }
        
        // Render blocked apps list
        if (blockedApps.length === 0) {
          blockedAppsList.innerHTML = `
            <div class="text-center py-8">
              <svg class="w-12 h-12 mx-auto text-textsec/30 mb-3" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z"></path>
              </svg>
              <p class="text-textsec text-sm">No blocked apps yet</p>
              <p class="text-textsec/60 text-xs mt-1">Add apps to block from the child's device</p>
            </div>
          `;
        } else {
          // Fetch app details for all blocked apps
          fetchAppDetailsForBlocked(childHash, blockedApps);
        }
        
        // Update quick add buttons visibility
        updateQuickAddButtons(childHash, blockedApps);
      }
    })
    .catch(error => {
      console.error('Error loading blocked apps:', error);
      blockedAppsList.innerHTML = `
        <div class="text-center py-8">
          <svg class="w-12 h-12 mx-auto text-red-500/50 mb-3" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
          </svg>
          <p class="text-red-400 text-sm">Failed to load blocked apps</p>
        </div>
      `;
    });
}

// Fetch app details for blocked apps from search API
async function fetchAppDetailsForBlocked(childHash, blockedApps) {
  const blockedAppsList = document.getElementById('blockedAppsList' + childHash);
  if (!blockedAppsList) return;
  
  // Show loading state
  blockedAppsList.innerHTML = `
    <div class="text-center py-8">
      <div class="inline-block animate-spin rounded-full h-8 w-8 border-b-2 border-primary mb-2"></div>
      <p class="text-textsec text-sm">Loading app details...</p>
    </div>
  `;
  
  try {
    // Fetch details for each app
    const appDetailsPromises = blockedApps.map(async (packageName) => {
      try {
        const response = await fetch(`/api/apps/search/?q=${encodeURIComponent(packageName)}`);
        const data = await response.json();
        
        if (data.status === 'success' && data.apps && data.apps.length > 0) {
          // Find exact match
          const exactMatch = data.apps.find(app => app.domain === packageName);
          if (exactMatch) {
            return {
              package_name: packageName,
              app_name: exactMatch.name,
              icon_url: exactMatch.icon
            };
          }
        }
        
        // Fallback if not found
        return {
          package_name: packageName,
          app_name: packageName.split('.').pop().charAt(0).toUpperCase() + packageName.split('.').pop().slice(1),
          icon_url: null
        };
      } catch (error) {
        console.error(`Error fetching details for ${packageName}:`, error);
        return {
          package_name: packageName,
          app_name: packageName.split('.').pop().charAt(0).toUpperCase() + packageName.split('.').pop().slice(1),
          icon_url: null
        };
      }
    });
    
    const blockedAppsDetails = await Promise.all(appDetailsPromises);
    
    // Render the blocked apps list with fetched details
    renderBlockedAppsList(childHash, blockedAppsDetails);
  } catch (error) {
    console.error('Error fetching app details:', error);
    // Fallback to simple list
    const fallbackDetails = blockedApps.map(packageName => ({
      package_name: packageName,
      app_name: packageName.split('.').pop().charAt(0).toUpperCase() + packageName.split('.').pop().slice(1),
      icon_url: null
    }));
    renderBlockedAppsList(childHash, fallbackDetails);
  }
}

// Render blocked apps list with details
function renderBlockedAppsList(childHash, blockedAppsDetails) {
  const blockedAppsList = document.getElementById('blockedAppsList' + childHash);
  if (!blockedAppsList) return;
  
  let appsHTML = '';
  blockedAppsDetails.forEach((appDetail, index) => {
    const packageName = appDetail.package_name;
    const appName = appDetail.app_name;
    const iconUrl = appDetail.icon_url;
    
    const colors = [
      'bg-red-500/20 border-red-500/40 text-red-400',
      'bg-orange-500/20 border-orange-500/40 text-orange-400',
      'bg-rose-500/20 border-rose-500/40 text-rose-400',
      'bg-pink-500/20 border-pink-500/40 text-pink-400',
    ];
    const colorClass = colors[index % colors.length];
    
    // Create icon element
    let iconElement = '';
    if (iconUrl) {
      iconElement = `
        <div class="w-10 h-10 flex-shrink-0 mr-3 bg-darkbg2 rounded-lg overflow-hidden flex items-center justify-center">
          <img src="${iconUrl}" alt="${appName}" class="w-full h-full object-cover" onerror="this.parentElement.innerHTML='<span class=\\'text-primary text-lg font-bold\\'>${appName.charAt(0)}</span>'">
        </div>
      `;
    } else {
      iconElement = `
        <div class="w-10 h-10 flex-shrink-0 mr-3 bg-darkbg2 rounded-lg overflow-hidden flex items-center justify-center">
          <span class="text-primary text-lg font-bold">${appName.charAt(0)}</span>
        </div>
      `;
    }
    
    appsHTML += `
      <div class="flex items-center justify-between p-4 ${colorClass} border rounded-xl hover:bg-opacity-30 transition-all group">
        <div class="flex items-center flex-1 min-w-0">
          ${iconElement}
          <div class="flex-1 min-w-0">
            <h4 class="font-semibold text-textmain text-sm mb-1">${appName}</h4>
            <p class="text-xs text-textsec/80 font-mono truncate">${packageName}</p>
          </div>
        </div>
        <button 
          onclick="removeBlockedApp('${childHash}', '${packageName}')"
          class="ml-3 px-3 py-2 bg-red-500/20 hover:bg-red-500 border border-red-500/40 hover:border-red-500 text-red-400 hover:text-white rounded-lg transition-all duration-200 flex items-center gap-2 text-xs font-semibold opacity-0 group-hover:opacity-100"
          title="Remove from blocked list"
        >
          <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
          </svg>
          Unblock
        </button>
      </div>
    `;
  });
  
  blockedAppsList.innerHTML = appsHTML;
}

// Update quick add buttons visibility based on blocked apps
function updateQuickAddButtons(childHash, blockedApps) {
  const quickAddContainer = document.getElementById('quickAddButtons' + childHash);
  if (!quickAddContainer) return;
  
  const buttons = quickAddContainer.querySelectorAll('.quick-block-btn');
  buttons.forEach(button => {
    const packageName = button.getAttribute('data-package');
    if (blockedApps.includes(packageName)) {
      button.classList.add('hidden-blocked');
    } else {
      button.classList.remove('hidden-blocked');
    }
  });
}

// Add a blocked app
function addBlockedApp(childHash) {
  const input = document.getElementById('newBlockedApp' + childHash);
  const packageName = input.value.trim();
  
  if (!packageName) {
    alert('Please enter an app package name');
    return
  }
  
  // Basic validation for package name format
  if (!packageName.includes('.')) {
    alert('Please enter a valid package name (e.g., com.example.app)');
    return;
  }
  
  // Get current blocked apps
  fetch('/api/blocked-apps/' + childHash + '/')
    .then(response => response.json())
    .then(data => {
      const blockedApps = data.blocked_apps || [];
      
      // Check if already blocked
      if (blockedApps.includes(packageName)) {
        alert('This app is already in the blocked list');
        return;
      }
      
      // Add to list
      blockedApps.push(packageName);
      
      // Update on server
      return updateBlockedAppsOnServer(childHash, blockedApps);
    })
    .then(success => {
      if (success) {
        input.value = ''; // Clear input
        loadBlockedApps(childHash); // Reload list
        showToast('App blocked successfully', 'success');
      }
    })
    .catch(error => {
      console.error('Error adding blocked app:', error);
      alert('Failed to add blocked app. Please try again.');
    });
}

// Quick block an app
function quickBlockApp(childHash, packageName, appName) {
  fetch('/api/blocked-apps/' + childHash + '/')
    .then(response => response.json())
    .then(data => {
      const blockedApps = data.blocked_apps || [];
      
      // Check if already blocked
      if (blockedApps.includes(packageName)) {
        showToast(appName + ' is already blocked', 'info');
        return;
      }
      
      // Add to list
      blockedApps.push(packageName);
      
      // Update on server
      return updateBlockedAppsOnServer(childHash, blockedApps);
    })
    .then(success => {
      if (success) {
        loadBlockedApps(childHash);
        showToast(appName + ' blocked successfully', 'success');
      }
    })
    .catch(error => {
      console.error('Error blocking app:', error);
      showToast('Failed to block ' + appName, 'error');
    });
}

// Remove a blocked app
function removeBlockedApp(childHash, packageName) {
  
  fetch('/api/blocked-apps/' + childHash + '/')
    .then(response => response.json())
    .then(data => {
      const blockedApps = data.blocked_apps || [];
      
      // Remove from list
      const updatedApps = blockedApps.filter(app => app !== packageName);
      
      // Update on server
      return updateBlockedAppsOnServer(childHash, updatedApps);
    })
    .then(success => {
      if (success) {
        loadBlockedApps(childHash);
        showToast('App unblocked successfully', 'success');
      }
    })
    .catch(error => {
      console.error('Error removing blocked app:', error);
      alert('Failed to unblock app. Please try again.');
    });
}

// Update blocked apps on server
function updateBlockedAppsOnServer(childHash, blockedApps) {
  return fetch('/api/blocked-apps/' + childHash + '/update/', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      'X-CSRFToken': getCookie('csrftoken')
    },
    body: JSON.stringify({ blocked_apps: blockedApps })
  })
  .then(response => response.json())
  .then(data => {
    if (data.status === 'success') {
      return true;
    } else {
      throw new Error(data.error || 'Failed to update');
    }
  });
}

// Helper function to get app name from package name
function getAppNameFromPackage(packageName) {
  const appNames = {
    'com.facebook.katana': 'Facebook',
    'com.instagram.android': 'Instagram',
    'com.whatsapp': 'WhatsApp',
    'com.snapchat.android': 'Snapchat',
    'com.zhiliaoapp.musically': 'TikTok',
    'com.twitter.android': 'Twitter/X',
    'com.google.android.youtube': 'YouTube',
    'com.netflix.mediaclient': 'Netflix',
    'com.spotify.music': 'Spotify',
    'com.reddit.frontpage': 'Reddit',
    'com.discord': 'Discord',
    'org.telegram.messenger': 'Telegram',
    'com.android.chrome': 'Chrome',
  };
  
  if (appNames[packageName]) {
    return appNames[packageName];
  }
  
  // Extract name from package (e.g., com.example.myapp -> Myapp)
  const parts = packageName.split('.');
  const lastPart = parts[parts.length - 1];
  return lastPart.charAt(0).toUpperCase() + lastPart.slice(1);
}

// Helper function to show toast notifications
function showToast(message, type = 'info') {
  const colors = {
    success: 'bg-green-500',
    error: 'bg-red-500',
    info: 'bg-cyan-500'
  };
  
  const toast = document.createElement('div');
  toast.className = `fixed bottom-4 right-4 ${colors[type]} text-white px-6 py-3 rounded-lg shadow-lg z-50 animate-fade-in-up`;
  toast.textContent = message;
  
  document.body.appendChild(toast);
  
  setTimeout(() => {
    toast.style.opacity = '0';
    toast.style.transform = 'translateY(10px)';
    toast.style.transition = 'all 0.3s ease';
    setTimeout(() => toast.remove(), 300);
  }, 3000);
}

// Get CSRF token from cookies
function getCookie(name) {
  let cookieValue = null;
  if (document.cookie && document.cookie !== '') {
    const cookies = document.cookie.split(';');
    for (let i = 0; i < cookies.length; i++) {
      const cookie = cookies[i].trim();
      if (cookie.substring(0, name.length + 1) === (name + '=')) {
        cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
        break;
      }
    }
  }
  return cookieValue;
}

// Load blocked apps when selecting a child
const originalSelectChildForBlocked = window.selectChild;
window.selectChild = function(childHash) {
  originalSelectChildForBlocked(childHash);
  // Load blocked apps after a short delay to ensure dashboard is visible
  setTimeout(() => loadBlockedApps(childHash), 300);
}
</script>
